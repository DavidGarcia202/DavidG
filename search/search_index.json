{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"David Garc\u00eda","text":"<p>Hola! \ud83d\udc4b Esta es la p\u00e1gina web de David Garc\u00eda destinada para reportar tareas y proyectos de las materias Proyectos 4 y Sistemas Embebidos.</p>"},{"location":"Ejemplos/comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"Ejemplos/comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"Ejemplos/comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"Ejemplos/comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"Ejemplos/comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"Ejemplos/comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"Ejemplos/comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"Ejemplos/comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"Ejemplos/comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"Ejemplos/comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"Ejemplos/comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Ejemplos/comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"Ejemplos/comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"Ejemplos/comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"Ejemplos/comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"Ejemplos/comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"Ejemplos/ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Ejemplos/ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Ejemplos/ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Ejemplos/ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Ejemplos/ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Ejemplos/ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Ejemplos/gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"Ejemplos/gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"Ejemplos/gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"Ejemplos/gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"Ejemplos/gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"Ejemplos/gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"Ejemplos/gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"Ejemplos/gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Proyectos4/1_Perfil/","title":"\ud83d\udcbfPerfil","text":""},{"location":"Proyectos4/1_Perfil/#soy-juan-david-garcia-cortez-estoy-en-quinto-semestre-de-ingenieria-mecatronica-en-este-momento-de-mi-vida-me-gustaria-trabajar-en-el-desarrollo-de-instalaciones-interactivas-o-en-robots-de-ensamble","title":"Soy Juan David Garc\u00eda Cortez, estoy en quinto semestre de Ingenier\u00eda Mecatr\u00f3nica, en este momento de mi vida me gustar\u00eda trabajar en el desarrollo de instalaciones interactivas o en robots de ensamble.","text":""},{"location":"Proyectos4/Costos/","title":"Costos","text":"<p>Costos de David Garc\u00eda</p>"},{"location":"Proyectos4/Gannt/","title":"Diagrama de Gannt","text":""},{"location":"Proyectos4/Proyecto/","title":"Nuestro Proyecto","text":"<p>Proyecto de Sumie Arai, David Garcia y Rodrigo Miranda </p>"},{"location":"Proyectos4/ProyectoFInal/","title":"Proyecto Final","text":""},{"location":"Proyectos4/ProyectoFInal/#documentacion-final","title":"Documentaci\u00f3n final","text":""},{"location":"Proyectos4/ProyectoFInal/#presentacion-final","title":"Presentaci\u00f3n final","text":"<p>Sumie ARAI Erazo rodrigo miranda de Sumie Arai</p>"},{"location":"Proyectos4/ProyectoFInal/#video-de-la-aplicacion","title":"Video de la aplicaci\u00f3n","text":""},{"location":"Proyectos4/ProyectoFInal/#video-de-la-inteligencia-artificial","title":"Video de la inteligencia artificial","text":""},{"location":"Proyectos4/Semana2/","title":"Semana 2","text":""},{"location":"Proyectos4/Semana2/#capsulas-de-cafe","title":"C\u00e1psulas de Caf\u00e9","text":"<p>C\u00e1psulas de Caf\u00e9 de Sumie Arai, David Garc\u00eda</p>"},{"location":"Proyectos4/Semana2/#nuestro-proyecto","title":"Nuestro Proyecto","text":"<p>Presentaci\u00f3n extra</p>"},{"location":"Proyectos4/Semana4/","title":"Semana 4","text":""},{"location":"Proyectos4/Semana4/#por-que-mi-proyecto-es-importante","title":"\u00bfPor qu\u00e9 mi proyecto es importante?","text":"<p>Estacionamiento Inteligente de Sumie Arai</p>"},{"location":"Proyectos4/Semana5/","title":"Segmentaci\u00f3n","text":"<p>Tabla de Valor de David Garc\u00eda, Sumie Arai y Rodrigo Miranda</p> <p>Segmentaci\u00f3n de David Garc\u00eda, Sumie Arai y Rodrigo Miranda</p>"},{"location":"Proyectos4/Syllabus/","title":"Syllabus Firmado","text":""},{"location":"Sistemas%20Embebidos/EXAMEN2/","title":"\ud83d\udcda Examen 2do Parcial","text":""},{"location":"Sistemas%20Embebidos/EXAMEN2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo  </li> <li>Curso / Asignatura: Sistemas embebidos 1  </li> <li>Fecha: 23/10/25  </li> <li>Descripci\u00f3n breve: _Examen 2do Parcial. _</li> </ul>"},{"location":"Sistemas%20Embebidos/EXAMEN2/#2-instrucciones","title":"2) Instrucciones","text":"<ul> <li>Hardware m\u00ednimo: 1 \u00d7 servomotor en un pin PWM (50 Hz).<ul> <li>Hardware m\u00ednimo: 3 \u00d7 botones: BTN_MODE (cambia modo), BTN_NEXT (siguiente), BTN_PREV (anterior).</li> <li>Usar Raspberry Pi Pico como controlador.</li> <li>Modo Entrenamiento: recibir comandos por USB-serial (borrar/clear, escribir/write, reemplazar/replace) y responder OK o errores seg\u00fan validez de argumentos.</li> <li>Modo Continuo: recorrer todas las posiciones de la lista en orden y mostrar cada 1.5 s el texto \"posX: V\"; si la lista est\u00e1 vac\u00eda, imprimir \"Error no hay pos\" cada 1.5 s y no mover el servo.</li> <li>Modo Step: BTN_NEXT avanza una posici\u00f3n (no pasa de la \u00faltima); BTN_PREV retrocede (no baja de la primera); en cada cambio imprimir \"posX: V\" y mover el servo; si la lista est\u00e1 vac\u00eda, al presionar los botones imprimir \"Error no hay pos\" y no mover el servo.</li> <li>Comandos seriales (aceptar may\u00fasculas/min\u00fasculas y aliases en ingl\u00e9s):<ul> <li>Borrar / clear: sintaxis \"Borrar\" \u2014 elimina la lista completa de posiciones \u2014 respuesta: OK.</li> <li>Escribir / write: sintaxis \"Escribir, v1, v2, ..., vn\" con valores 0\u2013180 \u2014 sobrescribe la lista \u2014 respuesta: OK si v\u00e1lidos; si alguno inv\u00e1lido o lista vac\u00eda \u2192 \"Error argumento invalido\".</li> <li>Reemplazar / replace: sintaxis \"Reemplazar, i, v\" con i base 1 y v en 0\u2013180 \u2014 reemplaza posici\u00f3n i por v \u2014 respuesta: OK; si i no existe \u2192 \"Error indice invalido\"; si v fuera de rango \u2192 \"Error argumento invalido\".</li> </ul> </li> <li>Formato de salida serial en modos: imprimir \"posX: V\" donde X es \u00edndice base 1 y V el \u00e1ngulo.</li> <li>Nota de conexi\u00f3n y PWM: el movimiento del servo requiere alimentaci\u00f3n 5\u20136 V; la se\u00f1al de control se conecta al pin de se\u00f1al del servo; la frecuencia PWM debe ser 50 Hz y el pulso de control entre 1 ms (0\u00b0) y 2 ms (180\u00b0).</li> </ul> </li> </ul>"},{"location":"Sistemas%20Embebidos/EXAMEN2/#3-materiales","title":"3) Materiales","text":"<ul> <li>Incluye:    -1 servomotor.   -3 botones, resistencias pulldown de 1k, 1 motor DC._</li> </ul>"},{"location":"Sistemas%20Embebidos/EXAMEN2/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;                          // include de C: funciones de entrada/salida (printf, getchar, etc.)\n#include \"pico/stdlib.h\"                    // SDK de la Raspberry Pi Pico: sleep_ms, stdio_init_all, make_timeout_time_ms, funciones de tiempo y stdio USB\n#include \"hardware/pwm.h\"                  // API hardware para PWM en la Pico (pwm_set_chan_level, pwm_set_wrap, pwm_set_clkdiv, etc.)\n#include \"hardware/gpio.h\"                 // API hardware para GPIO (gpio_init, gpio_set_dir, gpio_pull_up, gpio_set_irq_enabled, gpio_get, etc.)\n#include &lt;string&gt;                           // std::string (clase C++ para manejo de cadenas)\n#include &lt;vector&gt;                           // std::vector (contenedor din\u00e1mico C++)\n#include &lt;cctype&gt;                           // funciones para caracteres: isdigit, tolower, etc.\n\n#define SERVO_PIN 15                       // Macro: nombre simb\u00f3lico para pin del servo (GPIO 15). Reemplazo por el preprocesador.\n#define BTN_MODE 2                         // Pin del bot\u00f3n que cambia el modo (GPIO 2)\n#define BTN_NEXT 3                         // Pin del bot\u00f3n \"siguiente\" (GPIO 3)\n#define BTN_PREV 4                         // Pin del bot\u00f3n \"anterior\" (GPIO 4)\n\nusing namespace std;                       // Evita escribir std:: antes de string, vector, etc. (\u00fatil pero puede contaminar el namespace)\n\n\n// --- Variables globales ---\nvector&lt;int&gt; posiciones;                    // Vector din\u00e1mico de enteros: lista de \u00e1ngulos (0-180) que el servo debe usar.\nint indice_actual = 0;                     // \u00cdndice actual dentro de 'posiciones' (base 0)\nvolatile int modo_actual = 1;              // Variable compartida con la ISR: modo actual (1=Entrenamiento,2=Continuo,3=Step)\nvolatile bool ciclo_activo = false;        // Bandera compartida: si el ciclo del modo continuo est\u00e1 activo o no\n                                          // 'volatile' evita optimizaciones que asumir\u00edan que la variable no cambia fuera del flujo principal.\n\n\n// --- Funciones auxiliares ---\nbool es_numero(const string&amp; str) {        // Funci\u00f3n: devuelve true si 'str' contiene solo d\u00edgitos o un '-' al inicio (permite negativos)\n    if (str.empty()) return false;         // Si cadena vac\u00eda -&gt; no es n\u00famero\n    for (char c : str) {                   // Recorre cada car\u00e1cter de la cadena\n        if (!isdigit(c) &amp;&amp; c != '-') return false; // isdigit() viene de &lt;cctype&gt;; si no es d\u00edgito ni '-', no es n\u00famero v\u00e1lido\n    }\n    return true;                           // Si todos los caracteres pasaron la prueba, es n\u00famero (o probable n\u00famero con signo)\n}\n\nint string_a_int(const string&amp; str) {      // Convierte cadena decimal a int SIN usar stoi (control manual de errores)\n    int resultado = 0;                     // Acumulador del n\u00famero\n    int signo = 1;                         // Factor de signo (1 o -1)\n    size_t inicio = 0;                     // Posici\u00f3n de inicio para lectura (si hay '-', empezamos en 1)\n    if (str[0] == '-') {                   // Si el primer car\u00e1cter es '-', manejamos negativo\n        signo = -1;\n        inicio = 1;\n    }\n    for (size_t i = inicio; i &lt; str.length(); i++) { // Recorre desde 'inicio' hasta el final\n        if (isdigit(str[i])) {             // Si el car\u00e1cter es d\u00edgito\n            resultado = resultado * 10 + (str[i] - '0'); // Convierte car\u00e1cter a n\u00famero: '3' -&gt; 3 sum\u00e1ndolo en base 10\n        } else {\n            return -9999;                  // C\u00f3digo de error: se encontr\u00f3 car\u00e1cter inv\u00e1lido (evita excepciones)\n        }\n    }\n    return resultado * signo;              // Devuelve el valor con signo\n}\n\nvoid mostrar_bienvenida() {                // Imprime por serial el men\u00fa y comandos disponibles\n    printf(\"\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"    SISTEMA DE CONTROL DE SERVO\\n\");\n    printf(\"         Raspberry Pi Pico\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"Modos disponibles:\\n\");\n    printf(\"  1 - Entrenamiento\\n\");\n    printf(\"  2 - Continuo\\n\");\n    printf(\"  3 - Step\\n\");\n    printf(\"\\n\");\n    printf(\"Comandos disponibles:\\n\");\n    printf(\"  escribir, write - Guardar posiciones\\n\");\n    printf(\"  borrar, clear   - Borrar lista\\n\");\n    printf(\"  reemplazar, replace - Modificar posicion\\n\");\n    printf(\"  help, ayuda     - Mostrar este mensaje\\n\");\n    printf(\"\\n\");\n    printf(\"Presiona BTN_MODE para cambiar modos\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"\\n\");\n}\n\nvoid borrar_lista() {                      // Borra el vector de posiciones y reinicia el \u00edndice\n    posiciones.clear();                    // .clear() borra todos los elementos del vector (tama\u00f1o=0)\n    indice_actual = 0;                     // Reinicia \u00edndice\n    printf(\"OK\\n\");                        // Confirma la operaci\u00f3n por serial\n}\n\nuint16_t angle_to_level(uint16_t angle) {  // Convierte \u00e1ngulo (0-180) a nivel PWM (0-65535)\n    // Para servo est\u00e1ndar: 0\u00b0 = 1000us, 180\u00b0 = 2000us\n    float min_pulse_us = 1000.0f;          // Pulso m\u00ednimo en microsegundos (1 ms) equivalente a 0\u00b0\n    float max_pulse_us = 2000.0f;          // Pulso m\u00e1ximo en microsegundos (2 ms) equivalente a 180\u00b0\n    float period_us = 20000.0f;            // Periodo total en microsegundos: 20 ms = 1 / 50 Hz (50 Hz t\u00edpico de servos)\n\n    // Calcular pulso para el \u00e1ngulo (interpolaci\u00f3n lineal)\n    float pulse_us = min_pulse_us + (angle * (max_pulse_us - min_pulse_us) / 180.0f);\n    // Explicaci\u00f3n: (max - min) es la amplitud del pulso; se escala por angle/180 para mapear 0..180 a 0..(max-min).\n\n    // Convertir a nivel PWM de 16 bits:\n    // PWM level = (pulse_us / period_us) * 65535\n    // 65535 es el valor m\u00e1ximo del contador cuando wrap=65535 (resoluci\u00f3n 16-bit).\n    return (uint16_t)((pulse_us / period_us) * 65535.0f);\n}\n\nvoid mover_servo(uint slice, uint chan, int ang) { // Env\u00eda el valor PWM correspondiente al \u00e1ngulo\n    if (ang &lt; 0) ang = 0;                  // Clampa \u00e1ngulo m\u00ednimo\n    if (ang &gt; 180) ang = 180;              // Clampa \u00e1ngulo m\u00e1ximo\n    pwm_set_chan_level(slice, chan, angle_to_level(ang)); // Llama al SDK: fija el nivel del canal PWM\n    // pwm_set_chan_level(slice,chan,level) escribe el valor (0..wrap) que se mantiene activo en cada ciclo PWM.\n}\n\n// Interrupci\u00f3n para cambiar modo\nvoid gpio_callback(uint gpio, uint32_t events) { // Funci\u00f3n llamada por la IRQ del GPIO (callback)\n    if (gpio == BTN_MODE) {                  // Si la interrupci\u00f3n vino del pin BTN_MODE\n        modo_actual++;                       // Incrementa modo c\u00edclicamente\n        if (modo_actual &gt; 3) modo_actual = 1;// Vuelve a 1 despu\u00e9s de 3 (1-&gt;2-&gt;3-&gt;1)\n        ciclo_activo = (modo_actual == 2);   // Si modo==2 (Continuo), activa el ciclo; si no, lo desactiva\n\n        printf(\"\\n=== Modo cambiado ===\\n\");  // Mensaje de cambio de modo\n        switch(modo_actual) {                // Muestra texto seg\u00fan el modo\n            case 1: printf(\"MODO ENTRENAMIENTO activado\\n\"); break;\n            case 2: printf(\"MODO CONTINUO activado\\n\"); break;\n            case 3: printf(\"MODO STEP activado\\n\"); break;\n        }\n        printf(\"=====================\\n\");\n\n        if (!posiciones.empty()) {           // Si hay posiciones cargadas, reinicia el \u00edndice a 0\n            indice_actual = 0;\n        }\n    }\n}\n\n// Procesar comando de consola\nvoid procesar_comando(const string&amp; cmd, uint slice, uint chan) { // Recibe el comando como string y los ids PWM slice/chan\n    string cmd_lower = cmd;                 // Copia del comando\n    for (char &amp;c : cmd_lower) c = tolower(c); // Convierte todos los caracteres a min\u00fasculas para comparar sin case-sensitivity\n\n    if (cmd_lower == \"write\" || cmd_lower == \"escribir\") { // Comando para escribir posiciones\n        printf(\"Ingresa valores separados por comas (ej: 0,90,130): \");\n        string entrada = \"\";\n\n        absolute_time_t timeout = make_timeout_time_ms(10000); // Crea un timeout de 10 s (evita bloqueo indefinido)\n        while (true) {                       // Bucle para leer caracteres desde stdio (USB serial)\n            int c = getchar_timeout_us(100000); // Lee con timeout en microsegundos (100000us = 100ms)\n            if (c != PICO_ERROR_TIMEOUT) {   // Si hay dato disponible\n                if (c == '\\n' || c == '\\r') break; // Enter -&gt; fin de entrada\n                entrada += (char)c;         // Agrega car\u00e1cter a la cadena\n                printf(\"%c\", c);            // Eco del car\u00e1cter (para ver lo que se escribe)\n            }\n            if (time_reached(timeout)) {    // Si el tiempo de entrada expir\u00f3\n                printf(\"\\nError: timeout en entrada\\n\");\n                return;                     // Sale sin procesar (evita bloquear)\n            }\n        }\n        printf(\"\\n\");\n\n        if (entrada.empty()) {              // Si no se ingres\u00f3 nada\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        vector&lt;int&gt; temp_pos;               // Vector temporal donde guardaremos los valores parseados\n        string temp = \"\";\n\n        for (char c : entrada) {            // Parseo manual de la lista separada por comas\n            if (c == ',') {                 // Si encontramos separador\n                if (!temp.empty()) {\n                    if (!es_numero(temp)) { // Validaci\u00f3n: temp debe ser num\u00e9rico\n                        printf(\"Error argumento invalido\\n\");\n                        return;\n                    }\n                    int val = string_a_int(temp); // Conversi\u00f3n segura a int\n                    if (val &lt; 0 || val &gt; 180) {   // Validaci\u00f3n de rango de \u00e1ngulo\n                        printf(\"Error argumento invalido\\n\");\n                        return;\n                    }\n                    temp_pos.push_back(val);  // A\u00f1ade al vector temporal\n                    temp = \"\";                // Resetea temp para el siguiente n\u00famero\n                }\n            } else if (c != ' ') {          // Ignora espacios\n                temp += c;                  // Acumula car\u00e1cter\n            }\n        }\n        if (!temp.empty()) {                // Si qued\u00f3 un \u00faltimo n\u00famero tras el \u00faltimo separador\n            if (!es_numero(temp)) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            int val = string_a_int(temp);\n            if (val &lt; 0 || val &gt; 180) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            temp_pos.push_back(val);\n        }\n\n        if (temp_pos.empty()) {             // Si no se logr\u00f3 parsear nada v\u00e1lido\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        posiciones = temp_pos;              // Asigna el vector parseado a la variable global\n        indice_actual = 0;                  // Reinicia \u00edndice\n        printf(\"OK - %d posiciones guardadas: \", (int)posiciones.size());\n        for (size_t i = 0; i &lt; posiciones.size(); i++) { // Muestra las posiciones guardadas\n            printf(\"%d\", posiciones[i]);\n            if (i &lt; posiciones.size() - 1) printf(\", \");\n        }\n        printf(\"\\n\");\n\n    } else if (cmd_lower == \"clear\" || cmd_lower == \"borrar\") { // Comando borrar lista\n        borrar_lista();\n\n    } else if (cmd_lower == \"replace\" || cmd_lower == \"reemplazar\") { // Reemplazar una posici\u00f3n dada\n        printf(\"Ingresa posicion,valor (ej: 1,130): \");\n        string entrada = \"\";\n        absolute_time_t timeout = make_timeout_time_ms(10000);\n        while (true) {\n            int c = getchar_timeout_us(100000);\n            if (c != PICO_ERROR_TIMEOUT) {\n                if (c == '\\n' || c == '\\r') break;\n                entrada += (char)c;\n                printf(\"%c\", c);\n            }\n            if (time_reached(timeout)) {\n                printf(\"\\nError: timeout en entrada\\n\");\n                return;\n            }\n        }\n        printf(\"\\n\");\n        if (entrada.empty()) {\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        int pos = -1, val = -1;             // Inicializa variables para \u00edndice (pos) y valor (val)\n        string temp = \"\";\n        bool sep = false;                   // Indica si ya le\u00edmos la coma separadora\n        for (char c : entrada) {\n            if (c == ',' &amp;&amp; !sep) {         // En la primera coma separamos posici\u00f3n y valor\n                if (!es_numero(temp)) {\n                    printf(\"Error argumento invalido\\n\");\n                    return;\n                }\n                pos = string_a_int(temp) - 1; // La interfaz pide posiciones 1-based, internamente se usa 0-based =&gt; restamos 1\n                if (pos == -10000) {        // Verifica c\u00f3digos de error (aunque string_a_int devuelve -9999, es chequeo defensivo)\n                    printf(\"Error argumento invalido\\n\");\n                    return;\n                }\n                temp = \"\";\n                sep = true;\n            } else if (c != ' ') {\n                temp += c;                  // Acumula el valor despu\u00e9s de la coma\n            }\n        }\n        if (sep &amp;&amp; !temp.empty()) {         // Si hubo coma y qued\u00f3 valor para leer\n            if (!es_numero(temp)) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            val = string_a_int(temp);\n            if (val == -9999) {            // C\u00f3digo de error desde string_a_int\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n        }\n\n        if (pos &lt; 0 || pos &gt;= (int)posiciones.size()) { // Validaci\u00f3n del \u00edndice dentro del vector\n            printf(\"Error indice invalido\\n\");\n        } else if (val &lt; 0 || val &gt; 180) {  // Validaci\u00f3n del nuevo valor\n            printf(\"Error argumento invalido\\n\");\n        } else {\n            posiciones[pos] = val;          // Reemplaza la posici\u00f3n solicitada\n            printf(\"OK - Posicion %d actualizada a %d grados\\n\", pos + 1, val); // Muestra confirmaci\u00f3n (pos+1 para usuario)\n        }\n\n    } else if (cmd_lower == \"help\" || cmd_lower == \"ayuda\" || cmd_lower == \"?\") { // Comando ayuda\n        mostrar_bienvenida();\n\n    } else {                               // Comando no reconocido\n        printf(\"Comando no reconocido: '%s'\\n\", cmd.c_str());\n        printf(\"Escribe 'help' para ver comandos disponibles\\n\");\n    }\n}\n\n// --- Programa principal ---\nint main() {\n    // Inicializar USB serial\n    stdio_init_all();                      // Inicializa stdio (incluye USB-Serial si est\u00e1 habilitado en la build)\n\n    // Esperar a que se conecte el monitor serial\n    sleep_ms(3000);                        // Pausa 3000 ms para dar tiempo al host a abrir el puerto serie\n\n    // Mostrar mensaje de bienvenida\n    mostrar_bienvenida();\n    printf(\"Sistema inicializado. Esperando comandos...\\n\");\n    printf(\"&gt; \");                          // Prompt para el usuario\n\n    // Configurar PWM para servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM); // Asigna la funci\u00f3n PWM al pin f\u00edsico SERVO_PIN (GPIO 15)\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN); // Obtiene el n\u00famero de \"slice\" PWM asociado a ese pin\n    uint chan = pwm_gpio_to_channel(SERVO_PIN); // Obtiene el canal (A/B) dentro del slice para ese pin\n    pwm_set_wrap(slice, 65535);            // 'wrap' define el valor m\u00e1ximo del contador PWM (aqu\u00ed 65535 \u2192 16 bits)\n\n    // Configurar el divisor para 50Hz\n    // Explicaci\u00f3n matem\u00e1tica:\n    // PWM_freq = sys_clock_hz / (clkdiv * (wrap + 1))\n    // =&gt; clkdiv = sys_clock_hz / (PWM_freq * (wrap + 1))\n    // En la Pico t\u00edpicamente sys_clock_hz = 125000000 (125 MHz)\n    // Con wrap = 65535 (=&gt; wrap+1 = 65536) y PWM_freq = 50 Hz:\n    // clkdiv \u2248 125e6 / (50 * 65536) \u2248 38.146...\n    // El autor escribi\u00f3 la f\u00f3rmula manipulando unidades para obtener el mismo resultado:\n    float div = 125.0f / (50.0f * 65535.0f / 1000000.0f);\n    // - 125.0f representa 125 MHz (la frecuencia base en MHz)\n    // - 65535.0f / 1000000.0f convierte el 'wrap' a \"mega-unidades\" para que las unidades cuadren.\n    // Resultado: div \u2248 38.15 -&gt; valor de clkdiv que produce ~50 Hz.\n    pwm_set_clkdiv(slice, div);            // Ajusta el divisor del reloj PWM (acepta float)\n    pwm_set_enabled(slice, true);          // Habilita el slice PWM\n\n    // Configurar botones (modo: entrada con pull-up)\n    gpio_init(BTN_MODE);                   // Inicializa pin BTN_MODE\n    gpio_set_dir(BTN_MODE, GPIO_IN);       // Configura como entrada\n    gpio_pull_up(BTN_MODE);                // Habilita resistencia interna pull-up (estado inactivo = 1)\n\n    gpio_init(BTN_NEXT);                   // Repite para BTN_NEXT\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    gpio_init(BTN_PREV);                   // Repite para BTN_PREV\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    // Configurar interrupci\u00f3n para BTN_MODE\n    gpio_set_irq_enabled(BTN_MODE, GPIO_IRQ_EDGE_FALL, true); // Habilita IRQ en flanco de bajada (bot\u00f3n presionado -&gt; GND)\n    gpio_set_irq_callback(gpio_callback); // Registra la funci\u00f3n callback para IRQs GPIO (llamada global en este SDK)\n    irq_set_enabled(IO_IRQ_BANK0, true);  // Habilita las interrupciones del banco de IO (necesario para que se ejecuten)\n\n    string mensaje_usb = \"\";               // Buffer para recibir caracteres desde USB (comando acumulado)\n    bool btn_next_prev = false;            // Estado previo del bot\u00f3n NEXT (para detectar flancos)\n    bool btn_prev_prev = false;            // Estado previo del bot\u00f3n PREV (para detectar flancos)\n\n    while (true) {                         // Bucle principal infinito\n        // Leer comandos por USB\n        int ch = getchar_timeout_us(1000); // Lee 1 car\u00e1cter con timeout de 1000 us (1 ms)\n        if (ch != PICO_ERROR_TIMEOUT) {   // Si se ley\u00f3 un car\u00e1cter v\u00e1lido\n            if (ch == '\\n' || ch == '\\r') { // Si se presion\u00f3 Enter\n                if (!mensaje_usb.empty()) { // Si hay texto acumulado\n                    procesar_comando(mensaje_usb, slice, chan); // Procesa el comando\n                    mensaje_usb = \"\";      // Limpia el buffer\n                    printf(\"&gt; \");         // Muestra prompt\n                }\n            } else {\n                mensaje_usb += (char)ch;   // Acumula car\u00e1cter en el buffer\n            }\n        }\n\n        // Modo Step (modo 3): mueve al siguiente/anterior cuando se detecta flanco de pulsaci\u00f3n\n        if (modo_actual == 3) {\n            bool btn_next_actual = !gpio_get(BTN_NEXT); // gpio_get devuelve 1 cuando no presionado (pull-up),\n                                                      // invertimos (!) para interpretar pulsado como true.\n            bool btn_prev_actual = !gpio_get(BTN_PREV); // Igual para PREV\n\n            if (btn_next_actual &amp;&amp; !btn_next_prev) { // Detecta flanco de subida (presi\u00f3n nueva)\n                if (posiciones.empty()) {\n                    printf(\"Error no hay pos\\n\");\n                } else {\n                    if (indice_actual &lt; (int)posiciones.size() - 1) { // Si no estamos al final, avanzamos\n                        indice_actual++;\n                    }\n                    mover_servo(slice, chan, posiciones[indice_actual]); // Mueve servo a la nueva posici\u00f3n\n                    printf(\"pos%d: %d\\n\", indice_actual + 1, posiciones[indice_actual]); // Imprime la pos (1-based)\n                }\n            }\n\n            if (btn_prev_actual &amp;&amp; !btn_prev_prev) { // Flanco para PREV\n                if (posiciones.empty()) {\n                    printf(\"Error no hay pos\\n\");\n                } else {\n                    if (indice_actual &gt; 0) {     // Si no estamos al inicio, retrocedemos\n                        indice_actual--;\n                    }\n                    mover_servo(slice, chan, posiciones[indice_actual]); // Mueve servo\n                    printf(\"pos%d: %d\\n\", indice_actual + 1, posiciones[indice_actual]);\n                }\n            }\n\n            btn_next_prev = btn_next_actual;     // Guarda estado actual para detectar flancos en la siguiente iteraci\u00f3n\n            btn_prev_prev = btn_prev_actual;\n        }\n\n        // Modo Continuo (modo 2): recorre todas las posiciones mientras ciclo_activo siga true\n        if (modo_actual == 2 &amp;&amp; ciclo_activo) {\n            if (posiciones.empty()) {\n                printf(\"Error no hay pos\\n\");\n                sleep_ms(1500);                // Espera 1.5 s antes de intentar de nuevo (evita loop r\u00e1pido de errores)\n            } else {\n                for (int i = 0; i &lt; (int)posiciones.size(); i++) { // Recorre todas las posiciones\n                    if (!ciclo_activo) break;   // Si ciclo_activo cambi\u00f3 (por pulsar mode), salimos\n                    mover_servo(slice, chan, posiciones[i]); // Mover servo a la posici\u00f3n i\n                    printf(\"pos%d: %d\\n\", i + 1, posiciones[i]);\n\n                    absolute_time_t start_time = get_absolute_time(); // Marca tiempo de inicio\n                    // Espera 1.5 s (1500000 us) de forma no bloqueante absoluta:\n                    while (absolute_time_diff_us(start_time, get_absolute_time()) &lt; 1500000) {\n                        sleep_ms(100);         // Pausa peque\u00f1a dentro del loop para que el MCU no consuma 100% CPU\n                        if (!ciclo_activo) break; // Permite salir r\u00e1pido si se desactiva ciclo_activo\n                    }\n                }\n            }\n        }\n\n        // Modo Entrenamiento (modo 1): permite mover con botones pero no iterar autom\u00e1ticamente\n        if (modo_actual == 1 &amp;&amp; !posiciones.empty()) {\n            bool btn_next_actual = !gpio_get(BTN_NEXT); // Lectura bot\u00f3n NEXT (presionado -&gt; true)\n            bool btn_prev_actual = !gpio_get(BTN_PREV); // Lectura bot\u00f3n PREV\n\n            if (btn_next_actual &amp;&amp; !btn_next_prev) { // Flanco nuevo\n                if (indice_actual &lt; (int)posiciones.size() - 1) {\n                    indice_actual++;\n                }\n                mover_servo(slice, chan, posiciones[indice_actual]); // Mueve servo a la posici\u00f3n actual\n                printf(\"Servo a %d\u00b0 (pos%d)\\n\", posiciones[indice_actual], indice_actual + 1);\n            }\n\n            if (btn_prev_actual &amp;&amp; !btn_prev_prev) { // Flanco nuevo para PREV\n                if (indice_actual &gt; 0) {\n                    indice_actual--;\n                }\n                mover_servo(slice, chan, posiciones[indice_actual]);\n                printf(\"Servo a %d\u00b0 (pos%d)\\n\", posiciones[indice_actual], indice_actual + 1);\n            }\n\n            btn_next_prev = btn_next_actual;       // Actualiza estados anteriores\n            btn_prev_prev = btn_prev_actual;\n        }\n\n        sleep_ms(10);                             // Peque\u00f1a pausa para evitar busy-loop agresivo\n    }\n\n    return 0; // No se alcanza porque while(true) es infinito, pero es buena pr\u00e1ctica devolver int\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/OutputsBasicos/","title":"\ud83d\udce4 Outputs B\u00e1sicos","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#garcia-cortez-juan-david-sistemas-embebidos-1-27082025","title":"Garcia Cortez Juan David \u00b7  Sistemas Embebidos 1  \u00b7  27/08/2025","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#contador-binario-4-bits","title":"Contador Binario 4 bits","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#en-cuatro-leds-debe-mostrarse-cad-segundo-la-representacion-binaria-del-0-al-15","title":"En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#_1","title":"\ud83d\udce4 Outputs B\u00e1sicos","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#conclusiones","title":"Conclusiones","text":"<ul> <li>Para un proyecto como una conosla de mezclas de m\u00fasica, la ESP32, resulta como la mejor opci\u00f3n, dado a su versatilidad y conectividad WiFi/Bluetooth integrado, facilitando la integraci\u00f3n y comunicaci\u00f3n con otros dispositivos. La Raspberry Pi Pico tambi\u00e9n es una opci\u00f3n flexible y potente, especialmente si se requiere procesamiento en paralelo o facilidad de programaci\u00f3n con MicroPython. Seguido de, tenemos la STM32F103C8T6 que es ideal para apliacaciones m\u00e1s industriales,pero no cuenta con una conectividad inal\u00e1mbrica, y su programaci\u00f3n puede llegar a ser m\u00e1s compleja. Finalmente, el ATmega328P puede quedarse corto para este tipo de proyectos, ya que se dificulta al manejar m\u00faltiples dispositivos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Proyecto/","title":"Proyecto Final micromouse","text":""},{"location":"Sistemas%20Embebidos/Proyecto/#resumen","title":"Resumen","text":"<ul> <li>Nombre del proyecto: Capstone Micromouse</li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cortez y Sumie Arai Erazo  </li> <li>Curso / Asignatura: Sistemas embebidos 1  </li> <li>Fecha: 10/12/25 </li> </ul>"},{"location":"Sistemas%20Embebidos/Proyecto/#objetivos","title":"Objetivos","text":"<ul> <li>El proyecto Micromouse consiste en dise\u00f1ar y programar un robot m\u00f3vil aut\u00f3nomo capaz de explorar un laberinto, construir un mapa y ejecutar una carrera r\u00e1pida (fast run) desde el inicio hasta el objetivo en el centro.</li> </ul>"},{"location":"Sistemas%20Embebidos/Proyecto/#arquitectura","title":"Arquitectura","text":""},{"location":"Sistemas%20Embebidos/Proyecto/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Proyecto/#diseno-de-la-pcb","title":"Dise\u00f1o de la PCB","text":""},{"location":"Sistemas%20Embebidos/Proyecto/#diseno-del-mecanismo","title":"Dise\u00f1o del mecanismo","text":""},{"location":"Sistemas%20Embebidos/Proyecto/#materiales","title":"Materiales","text":"<ul> <li>MDF</li> <li>Puente H, TB6612NF</li> <li>Rapberry Pi Pico</li> <li>Capacitores de 0.1, 10, 20, 100 microfaradios</li> <li>Transformador de voltaje a 3.3V</li> <li>Sensor TRT500</li> <li>Giroscopio MPU-6050</li> <li>Pila de 7.4 V y 0.2 A</li> <li>Motores pololu de 300 rev con encoder M20 y 949</li> <li>Switch</li> <li>Rueda Loca</li> <li>Llantas de 4 cm de di\u00e1metro  </li> </ul>"},{"location":"Sistemas%20Embebidos/Proyecto/#codigo-del-proyecto","title":"C\u00f3digo del Proyecto","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdint.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/i2c.h\"\n#include \"hardware/timer.h\"\n#include \"pico/time.h\"\n\n// ==========================================\n// 1. PINES\n// ==========================================\n#define LED_PIN 25\n#define I2C_PORT i2c0\n#define I2C_SDA 4\n#define I2C_SCL 5\n#define MPU6050_ADDR 0x68\n\n#define PWMA 9      \n#define AI1 10\n#define AI2 11\n#define PWMB 15     \n#define BI1 14\n#define BI2 13\n#define STBY 12\n\n#define ADC_CH_LEFT 0\n#define ADC_CH_FRONT 1\n#define ADC_CH_RIGHT 2\n\n#define ENC_A_PIN 8  \n#define ENC_B_PIN 16 \n\n// ==========================================\n// 2. CONSTANTES CALIBRADAS (ACTUALIZADAS)\n// ==========================================\n\n// Giroscopio escala\nconst float GYRO_SCALE = 30.0f;\nconst long TICKS_POR_CELDA = 1270;\n\n// VELOCIDAD\nconst int BASE_SPEED = 200;       \nconst int TURN_SPEED = 250;\nconst int REV_SPEED = 120; \n\n// ZONAS MUERTAS (Fricci\u00f3n m\u00ednima)\nconst int DEADZONE_A = 170; // Izquierdo\nconst int DEADZONE_B = 150; // Derecho\n\n// UMBRALES DE PARED \nconst uint16_t UMBRAL_FRONTAL = 2000;\nconst uint16_t UMBRAL_L_EXISTE = 1500;  \nconst uint16_t UMBRAL_R_EXISTE = 3500;  \n\n//  PID PARED (AVANCE) - Usa tus valores calibrados\nfloat Kp_Wall = 0.35f; \nfloat Kd_Wall = 4.0f; \nfloat prev_error_wall = 0;\n\n//  NUEVAS CONSTANTES: PID DE ANGULO (RECTITUD)\nfloat Kp_Angle = 1.8f;// Proporcional: Fuerza para corregir el \u00e1ngulo\nfloat Kd_Angle = 0.05f; // Derivativo: Amortigua la correcci\u00f3n (evita oscilaci\u00f3n r\u00e1pida)\nfloat target_angle_move = 0.0f; // El \u00e1ngulo al que debe apuntar el robot (se inicializa en avanzar_una_celda)\nfloat prev_error_angle = 0.0f;\n\n// --- PID REVERSA (NUEVO: PID COMPLETO) ---\n// Ajusta estos valores si vibra o no corrige suficiente\nfloat Kp_Rev = 12.0f;  // Fuerza de correcci\u00f3n principal\nfloat Kd_Rev = 0.8f;   // Amortiguaci\u00f3n (evita oscilaci\u00f3n)\nfloat Ki_Rev = 0.02f;  // Correcci\u00f3n de error acumulado\n\n// Variables globales PID Reversa\nfloat prev_error_rev = 0;\nfloat integral_rev = 0;\n\nint16_t gyro_offset_raw = 0;\nfloat current_global_angle = 0.0f; // Angulo acumulado\nuint16_t target_L = 220;\nuint16_t target_R = 2629;       \n\nabsolute_time_t time_to_enable_pid;\nvolatile long countA = 0;\n\n// ==========================================\n// 3. MATRICES Y LOGICA\n// ==========================================\n#define MAZE_SIZE 12\n\nint orientacion_actual = 0; // 0=N, 1=E, 2=S, 3=W\nint pos_x = 0;\nint pos_y = 0;\n\nuint8_t visited[MAZE_SIZE][MAZE_SIZE];\nuint8_t walls[MAZE_SIZE][MAZE_SIZE];\n\n// ==========================================\n// 4. HARDWARE\n// ==========================================\nvoid gpio_callback(uint gpio, uint32_t events) { if (gpio == ENC_A_PIN) countA++; }\n\nvoid mpu6050_init_standard() {\n    uint8_t buf[] = {0x6B, 0x00}; i2c_write_blocking(I2C_PORT, MPU6050_ADDR, buf, 2, false); sleep_ms(100);\n    uint8_t conf[] = {0x1B, 0x00}; i2c_write_blocking(I2C_PORT, MPU6050_ADDR, conf, 2, false); sleep_ms(10);\n}\n\nint16_t read_gyro_z() {\n    uint8_t buffer[2]; uint8_t reg = 0x47;\n    i2c_write_blocking(I2C_PORT, MPU6050_ADDR, &amp;reg, 1, true);\n    i2c_read_blocking(I2C_PORT, MPU6050_ADDR, buffer, 2, false);\n    return (int16_t)(buffer[0] &lt;&lt; 8 | buffer[1]);\n}\n\nvoid update_angle_global() {\n    static absolute_time_t t_prev_g = {0};\n    if (to_us_since_boot(t_prev_g) == 0) t_prev_g = get_absolute_time();\n\n    absolute_time_t t_now = get_absolute_time();\n    int64_t dt_us = absolute_time_diff_us(t_prev_g, t_now);\n    t_prev_g = t_now;\n\n    float dt = dt_us / 1000000.0f;\n    int16_t raw = read_gyro_z();\n\n    if (abs(raw - gyro_offset_raw) &lt; 20) return;\n\n    float dps = (raw - gyro_offset_raw) / GYRO_SCALE;\n    current_global_angle += dps * dt;\n}\n\nvoid setMotor(int motor, int pwm_val) {\n    int pinPWM = (motor == 0) ? PWMA : PWMB;\n    int pin1 = (motor == 0) ? AI1 : BI1; int pin2 = (motor == 0) ? AI2 : BI2;\n    int deadzone = (motor == 0) ? DEADZONE_A : DEADZONE_B;\n\n    int pwm_final = 0;\n    if (pwm_val &gt; 0) pwm_final = pwm_val + deadzone;\n    else if (pwm_val &lt; 0) pwm_final = pwm_val - deadzone;\n\n    if (pwm_final &gt; 950) pwm_final = 950;  \n    if (pwm_final &lt; -950) pwm_final = -950;\n\n    if (pwm_final &gt;= 0) { gpio_put(pin1, 0); gpio_put(pin2, 1); pwm_set_gpio_level(pinPWM, pwm_final); }\n    else { gpio_put(pin1, 1); gpio_put(pin2, 0); pwm_set_gpio_level(pinPWM, abs(pwm_final)); }\n}\n\nvoid init_all() {\n    stdio_init_all();\n    i2c_init(I2C_PORT, 400 * 1000);\n    gpio_set_function(I2C_SDA, GPIO_FUNC_I2C); gpio_pull_up(I2C_SDA);\n    gpio_set_function(I2C_SCL, GPIO_FUNC_I2C); gpio_pull_up(I2C_SCL);\n    mpu6050_init_standard();\n\n    gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    int pins_out[] = {AI1, AI2, BI1, BI2, STBY};\n    for(int i=0; i&lt;5; i++) { gpio_init(pins_out[i]); gpio_set_dir(pins_out[i], GPIO_OUT); }\n    gpio_put(STBY, 1);\n\n    gpio_set_function(PWMA, GPIO_FUNC_PWM); gpio_set_function(PWMB, GPIO_FUNC_PWM);\n    pwm_set_wrap(pwm_gpio_to_slice_num(PWMA), 1000); pwm_set_enabled(pwm_gpio_to_slice_num(PWMA), true);\n    pwm_set_wrap(pwm_gpio_to_slice_num(PWMB), 1000); pwm_set_enabled(pwm_gpio_to_slice_num(PWMB), true);\n\n    adc_init(); adc_gpio_init(26); adc_gpio_init(27); adc_gpio_init(28);\n    gpio_init(ENC_A_PIN); gpio_set_dir(ENC_A_PIN, GPIO_IN); gpio_pull_up(ENC_A_PIN);\n    gpio_set_irq_enabled_with_callback(ENC_A_PIN, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &amp;gpio_callback);\n\n    time_to_enable_pid = get_absolute_time();\n}\n\n// ==========================================\n// 5. MOVIMIENTOS\n// ==========================================\n\nvoid girar_grados(float grados_objetivo) {\n    setMotor(0,0); setMotor(1,0); sleep_ms(200);\n\n    float start_angle = current_global_angle;\n    float target_angle = start_angle + grados_objetivo;\n\n    while (true) {\n        update_angle_global();\n        float error = target_angle - current_global_angle;\n\n        if (fabs(error) &lt; 1.0) break; \n\n        int speed = TURN_SPEED;\n        if (fabs(error) &lt; 15.0) speed = 180; \n\n        if (error &gt; 0) { \n             setMotor(0, -speed); setMotor(1, speed);\n        } else { \n             setMotor(0, speed); setMotor(1, -speed);\n        }\n    }\n\n    setMotor(0, 0); setMotor(1, 0);\n    current_global_angle = round(current_global_angle / 90.0f) * 90.0f;\n    time_to_enable_pid = delayed_by_ms(get_absolute_time(), 300);\n    prev_error_wall = 0; sleep_ms(200);\n}\n\n// ==========================================\n// 6. LOGICA\n// ==========================================\n\nvoid decidir_y_mover() {\n          // 1. DETERMINAR DIRECCIONES Y COORDENADAS FUTURAS\n          int dir_frente = orientacion_actual;\n          int dir_der = (orientacion_actual + 1) % 4;\n          int dir_izq = (orientacion_actual + 3) % 4;\n\n          int dx[] = {0, 1, 0, -1};\n          int dy[] = {1, 0, -1, 0};\n\n          int next_x_F = pos_x + dx[dir_frente];\n          int next_y_F = pos_y + dy[dir_frente];\n          int next_x_R = pos_x + dx[dir_der];\n          int next_y_R = pos_y + dy[dir_der];\n          int next_x_L = pos_x + dx[dir_izq];\n          int next_y_L = pos_y + dy[dir_izq];\n\n          // 2. LECTURA DE PAREDES (HUECOS)\n          adc_select_input(ADC_CH_FRONT); bool pared_F = (adc_read() &lt; UMBRAL_FRONTAL);\n          adc_select_input(ADC_CH_LEFT);     bool pared_L = (adc_read() &lt; UMBRAL_L_EXISTE);     \n          adc_select_input(ADC_CH_RIGHT); bool pared_R = (adc_read() &lt; UMBRAL_R_EXISTE);\n\n          bool hueco_L = !pared_L;\n          bool hueco_R = !pared_R;\n          bool hueco_F = !pared_F; \n\n          // 3. ACTUALIZAR MAPA Y LOGS\n          senalizar_paredes(pared_L, pared_F, pared_R);\n          update_walls_real(pared_L, pared_F, pared_R);\n          printf(\"Pos(%d,%d) Ori:%d | L:%d F:%d R:%d\\n\", pos_x, pos_y, orientacion_actual, pared_L, pared_F, pared_R);\n\n          bool move_done = false;\n    bool avanzar_done = false; // Indica si avanz\u00f3 una celda completa\n\n          // Detecci\u00f3n de celdas NUEVAS v\u00e1lidas\n          bool nuevo_R = hueco_R &amp;&amp; es_valida(next_x_R, next_y_R) &amp;&amp; visited[next_x_R][next_y_R] == 0;\n          bool nuevo_F = hueco_F &amp;&amp; es_valida(next_x_F, next_y_F) &amp;&amp; visited[next_x_F][next_y_F] == 0;\n          bool nuevo_L = hueco_L &amp;&amp; es_valida(next_x_L, next_y_L) &amp;&amp; visited[next_x_L][next_y_L] == 0;\n\n          // ======================================================\n          // === PRIORIDAD 1: NUEVAS CELDAS (Derecha -&gt; Frente -&gt; Izquierda) ===\n          // ======================================================\n          if (nuevo_R) {\n                    printf(\"Decisi\u00f3n: Nuevo a la derecha\\n\");\n                    girar_grados(-90); \n                    orientacion_actual = dir_der;\n                    avanzar_done = avanzar_una_celda();\n                    move_done = true;\n          }\n          else if (nuevo_F) {\n                    printf(\"Decisi\u00f3n: Nuevo al frente\\n\");\n                    avanzar_done = avanzar_una_celda();\n                    move_done = true;\n          }\n          else if (nuevo_L) {\n                    printf(\"Decisi\u00f3n: Nuevo a la izquierda\\n\");\n                    girar_grados(90); \n                    orientacion_actual = dir_izq;\n                    avanzar_done = avanzar_una_celda();\n                    move_done = true;\n          }\n\n    // \ud83d\udd25 Si el avance fue interrumpido, el robot sigue en la misma celda. Forzar reevaluaci\u00f3n.\n    if (move_done &amp;&amp; !avanzar_done) { \n        printf(\"ADVERTENCIA: Avance frontal bloqueado. Reevaluando...\\n\");\n        // Reiniciamos move_done para pasar a la Prioridad 2/3.\n        move_done = false; \n    }\n\n          // Si la celda fue completada con \u00e9xito, actualizamos coordenadas.\n    if (move_done &amp;&amp; avanzar_done) {\n        pos_x = pos_x + dx[orientacion_actual]; \n        pos_y = pos_y + dy[orientacion_actual];\n    }\n\n          // ======================================================\n          // === PRIORIDAD 2: CELDAS VISITADAS (Frente -&gt; Derecha -&gt; Izquierda) ===\n          // ======================================================\n          if (!move_done) {\n\n                    // Celdas Viejas V\u00e1lidas que S\u00cd fueron visitadas antes\n                    bool viejo_F = hueco_F &amp;&amp; es_valida(next_x_F, next_y_F) &amp;&amp; visited[next_x_F][next_y_F] == 1;\n                    bool viejo_R = hueco_R &amp;&amp; es_valida(next_x_R, next_y_R) &amp;&amp; visited[next_x_R][next_y_R] == 1;\n                    bool viejo_L = hueco_L &amp;&amp; es_valida(next_x_L, next_y_L) &amp;&amp; visited[next_x_L][next_y_L] == 1;\n\n                    // Se prioriza el Frente para no girar innecesariamente\n                    if (viejo_F) {\n                              printf(\"Decisi\u00f3n: Frente visitado\\n\");\n                    }\n                    else if (viejo_R) {\n                              printf(\"Decisi\u00f3n: Derecha visitada\\n\");\n                              girar_grados(-90); \n                              orientacion_actual = dir_der;\n                    }\n                    else if (viejo_L) {\n                              printf(\"Decisi\u00f3n: Izquierda visitada\\n\");\n                              girar_grados(90); \n                              orientacion_actual = dir_izq;\n                    }\n\n                    // Si se tom\u00f3 una decisi\u00f3n de movimiento, ejecutar avance\n                    if (viejo_F || viejo_R || viejo_L) {\n                              avanzar_done = avanzar_una_celda();\n                              move_done = true;\n\n            if (avanzar_done) {\n                pos_x = pos_x + dx[orientacion_actual]; \n                pos_y = pos_y + dy[orientacion_actual];\n            } else {\n                // Si choca aqu\u00ed, forzamos la reevaluaci\u00f3n al Dead End\n                move_done = false;\n            }\n                    }\n          }\n\n          // ======================================================\n          // === PRIORIDAD 3: CALLEJ\u00d3N SIN SALIDA (Reversa) ===\n          // ======================================================\n    // Solo se ejecuta si move_done es FALSE (no hay huecos disponibles O se interrumpi\u00f3 por choque frontal)\n          if (!move_done) {\n                    printf(\"&gt;&gt; DEAD END -&gt; REVERSA PID\\n\");\n                    retroceder_una_celda_pid();\n\n                    // Retroceder en las coordenadas\n                    if (orientacion_actual == 0) pos_y--;\n                    else if (orientacion_actual == 1) pos_x--;\n                    else if (orientacion_actual == 2) pos_y++;\n                    else if (orientacion_actual == 3) pos_x++;\n          }\n}\n\n// === NUEVO: REVERSA PID COMPLETO (P + I + D) ===\nvoid retroceder_una_celda_pid() {\n    printf(\"&gt;&gt; REVERSA PID FULL (DEAD END)...\\n\");\n    countA = 0; \n\n    // Resetear variables PID\n    prev_error_rev = 0;\n    integral_rev = 0;\n\n    // Fijar el angulo objetivo como el actual (mantener rectitud)\n    float target_angle_rev = current_global_angle;\n\n    // Para calculo de derivada (dt)\n    absolute_time_t t_prev_pid = get_absolute_time();\n\n    while (countA &lt; TICKS_POR_CELDA) {\n        update_angle_global();\n\n        // Calculo dt\n        absolute_time_t t_now = get_absolute_time();\n        int64_t dt_us = absolute_time_diff_us(t_prev_pid, t_now);\n\n        // Evitar division por cero o dt muy peque\u00f1o\n        if (dt_us &lt; 1000) { sleep_us(100); continue; }\n        t_prev_pid = t_now;\n        float dt = dt_us / 1000000.0f; // Segundos\n\n        // Error: Diferencia entre angulo deseado y actual\n        float error = target_angle_rev - current_global_angle;\n\n        // Proporcional\n        float P = error * Kp_Rev;\n\n        // Integral (con anti-windup)\n        integral_rev += (error * dt);\n        if (integral_rev &gt; 10.0f) integral_rev = 10.0f;\n        if (integral_rev &lt; -10.0f) integral_rev = -10.0f;\n        float I = integral_rev * Ki_Rev;\n\n        // Derivativo\n        float D = ((error - prev_error_rev) / dt) * Kd_Rev;\n        prev_error_rev = error;\n\n        // Salida PID\n        float output = P + I + D;\n\n        // Limitar correccion\n        int correction = (int)output;\n        if (correction &gt; 150) correction = 150;\n        if (correction &lt; -150) correction = -150;\n\n        // Aplicar correccion a motores en reversa\n        // Si error &gt; 0 (robot mira izq), correccion positiva.\n        // Queremos enderezar a derecha. Motor DER debe frenar menos (ir mas rapido atras).\n        setMotor(0, -REV_SPEED - correction); \n        setMotor(1, -REV_SPEED + correction);\n\n        sleep_ms(1);\n    }\n    setMotor(0, 0); setMotor(1, 0); sleep_ms(300);\n}\n\n// ==========================================\n// 6. LOGICA\n// ==========================================\n\nvoid init_maps() {\n    for(int i=0; i&lt;MAZE_SIZE; i++) {\n        for(int j=0; j&lt;MAZE_SIZE; j++) { walls[i][j] = 0; visited[i][j] = 0; }\n    }\n}\n\nbool es_valida(int x, int y) {\n    return (x &gt;= 0 &amp;&amp; x &lt; MAZE_SIZE &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; MAZE_SIZE);\n}\n\nvoid update_walls_real(bool L, bool F, bool R) {\n    int abs_frente = orientacion_actual;\n    int abs_der = (orientacion_actual + 1) % 4;\n    int abs_izq = (orientacion_actual + 3) % 4;\n\n    int mask = 0;\n    if (F) mask |= (1 &lt;&lt; abs_frente);\n    if (R) mask |= (1 &lt;&lt; abs_der);\n    if (L) mask |= (1 &lt;&lt; abs_izq);\n\n    walls[pos_x][pos_y] |= mask;\n    visited[pos_x][pos_y] = 1;\n\n    if (mask &amp; 1 &amp;&amp; pos_y &lt; MAZE_SIZE - 1) walls[pos_x][pos_y+1] |= 4;\n    if (mask &amp; 2 &amp;&amp; pos_x &lt; MAZE_SIZE - 1) walls[pos_x+1][pos_y] |= 8;\n    if (mask &amp; 4 &amp;&amp; pos_y &gt; 0)             walls[pos_x][pos_y-1] |= 1;\n    if (mask &amp; 8 &amp;&amp; pos_x &gt; 0)             walls[pos_x-1][pos_y] |= 2;\n}\n\nvoid senalizar_paredes(bool L, bool F, bool R) {\n    if (F) { gpio_put(LED_PIN, 1); sleep_ms(50); gpio_put(LED_PIN, 0); sleep_ms(100); }\n    if (L) { gpio_put(LED_PIN, 1); sleep_ms(1000); gpio_put(LED_PIN, 0); sleep_ms(100); }\n    if (R) { gpio_put(LED_PIN, 1); sleep_ms(2000); gpio_put(LED_PIN, 0); sleep_ms(100); }\n}\n\n// ==========================================\n// 6. LOGICA (decidir_y_mover MODIFICADA)\n// ==========================================\n\n// [MODIFICADO] La llamada a avanzar_una_celda() ahora se hace con 'avanzar_done = avanzar_una_celda();'\n\n// ==========================================\n// 6. LOGICA\n// ==========================================\n\nvoid decidir_y_mover() {\n    // 1. DETERMINAR DIRECCIONES Y COORDENADAS FUTURAS\n    int dir_frente = orientacion_actual;\n    int dir_der = (orientacion_actual + 1) % 4;\n    int dir_izq = (orientacion_actual + 3) % 4;\n\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n\n    int next_x_F = pos_x + dx[dir_frente];\n    int next_y_F = pos_y + dy[dir_frente];\n    int next_x_R = pos_x + dx[dir_der];\n    int next_y_R = pos_y + dy[dir_der];\n    int next_x_L = pos_x + dx[dir_izq];\n    int next_y_L = pos_y + dy[dir_izq];\n\n    // 2. LECTURA DE PAREDES (HUECOS)\n    adc_select_input(ADC_CH_FRONT); bool pared_F = (adc_read() &lt; UMBRAL_FRONTAL);\n    adc_select_input(ADC_CH_LEFT);  bool pared_L = (adc_read() &lt; UMBRAL_L_EXISTE);  \n    adc_select_input(ADC_CH_RIGHT); bool pared_R = (adc_read() &lt; UMBRAL_R_EXISTE);\n\n    bool hueco_L = !pared_L;\n    bool hueco_R = !pared_R;\n    bool hueco_F = !pared_F; \n\n    // 3. ACTUALIZAR MAPA Y LOGS\n    senalizar_paredes(pared_L, pared_F, pared_R);\n    update_walls_real(pared_L, pared_F, pared_R);\n    printf(\"Pos(%d,%d) Ori:%d | L:%d F:%d R:%d\\n\", pos_x, pos_y, orientacion_actual, pared_L, pared_F, pared_R);\n\n    bool move_done = false;\n    bool avanzar_done = false; // Indica si avanz\u00f3 una celda completa\n\n    // Detecci\u00f3n de celdas NUEVAS v\u00e1lidas\n    bool nuevo_R = hueco_R &amp;&amp; es_valida(next_x_R, next_y_R) &amp;&amp; visited[next_x_R][next_y_R] == 0;\n    bool nuevo_F = hueco_F &amp;&amp; es_valida(next_x_F, next_y_F) &amp;&amp; visited[next_x_F][next_y_F] == 0;\n    bool nuevo_L = hueco_L &amp;&amp; es_valida(next_x_L, next_y_L) &amp;&amp; visited[next_x_L][next_y_L] == 0;\n\n    // ======================================================\n    // === PRIORIDAD 1: NUEVAS CELDAS (Derecha -&gt; Frente -&gt; Izquierda) ===\n    // ======================================================\n    if (nuevo_R) {\n        printf(\"Decisi\u00f3n: Nuevo a la derecha\\n\");\n        girar_grados(-90); \n        orientacion_actual = dir_der;\n        avanzar_done = avanzar_una_celda();\n        move_done = true;\n    }\n    else if (nuevo_F) {\n        printf(\"Decisi\u00f3n: Nuevo al frente\\n\");\n        avanzar_done = avanzar_una_celda();\n        move_done = true;\n    }\n    else if (nuevo_L) {\n        printf(\"Decisi\u00f3n: Nuevo a la izquierda\\n\");\n        girar_grados(90); \n        orientacion_actual = dir_izq;\n        avanzar_done = avanzar_una_celda();\n        move_done = true;\n    }\n\n    // \ud83d\udd25 Si el avance fue interrumpido, el robot sigue en la misma celda. Forzar reevaluaci\u00f3n.\n    if (move_done &amp;&amp; !avanzar_done) { \n        printf(\"ADVERTENCIA: Avance frontal bloqueado. Reevaluando...\\n\");\n        // Reiniciamos move_done para pasar a la Prioridad 2/3.\n        move_done = false; \n    }\n\n    // Si la celda fue completada con \u00e9xito, actualizamos coordenadas.\n    if (move_done &amp;&amp; avanzar_done) {\n        pos_x = pos_x + dx[orientacion_actual]; \n        pos_y = pos_y + dy[orientacion_actual];\n    }\n\n    // ======================================================\n    // === PRIORIDAD 2: CELDAS VISITADAS (Frente -&gt; Derecha -&gt; Izquierda) ===\n    // ======================================================\n    if (!move_done) {\n\n        // Celdas Viejas V\u00e1lidas que S\u00cd fueron visitadas antes\n        bool viejo_F = hueco_F &amp;&amp; es_valida(next_x_F, next_y_F) &amp;&amp; visited[next_x_F][next_y_F] == 1;\n        bool viejo_R = hueco_R &amp;&amp; es_valida(next_x_R, next_y_R) &amp;&amp; visited[next_x_R][next_y_R] == 1;\n        bool viejo_L = hueco_L &amp;&amp; es_valida(next_x_L, next_y_L) &amp;&amp; visited[next_x_L][next_y_L] == 1;\n\n        // Se prioriza el Frente para no girar innecesariamente\n        if (viejo_F) {\n            printf(\"Decisi\u00f3n: Frente visitado\\n\");\n        }\n        else if (viejo_R) {\n            printf(\"Decisi\u00f3n: Derecha visitada\\n\");\n            girar_grados(-90); \n            orientacion_actual = dir_der;\n        }\n        else if (viejo_L) {\n            printf(\"Decisi\u00f3n: Izquierda visitada\\n\");\n            girar_grados(90); \n            orientacion_actual = dir_izq;\n        }\n\n        // Si se tom\u00f3 una decisi\u00f3n de movimiento, ejecutar avance\n        if (viejo_F || viejo_R || viejo_L) {\n            avanzar_done = avanzar_una_celda();\n            move_done = true;\n\n            if (avanzar_done) {\n                pos_x = pos_x + dx[orientacion_actual]; \n                pos_y = pos_y + dy[orientacion_actual];\n            } else {\n                // Si choca aqu\u00ed, forzamos la reevaluaci\u00f3n al Dead End\n                move_done = false;\n            }\n        }\n    }\n\n    // ======================================================\n    // === PRIORIDAD 3: CALLEJ\u00d3N SIN SALIDA (Reversa) ===\n    // ======================================================\n    // Solo se ejecuta si move_done es FALSE (no hay huecos disponibles O se interrumpi\u00f3 por choque frontal)\n    if (!move_done) {\n        printf(\"&gt;&gt; DEAD END -&gt; REVERSA PID\\n\");\n        retroceder_una_celda_pid();\n\n        // Retroceder en las coordenadas\n        if (orientacion_actual == 0) pos_y--;\n        else if (orientacion_actual == 1) pos_x--;\n        else if (orientacion_actual == 2) pos_y++;\n        else if (orientacion_actual == 3) pos_x++;\n    }\n}\n// ==========================================\n// 7. MAIN\n// ==========================================\nint main() {\n    init_all();\n    sleep_ms(1000);\n\n    // Calibrar Gyro\n    long sum = 0; for(int i=0; i&lt;300; i++) { sum += read_gyro_z(); sleep_ms(2); }  \n    gyro_offset_raw = sum / 300;\n\n    for(int i=0; i&lt;5; i++) { gpio_put(LED_PIN, 1); sleep_ms(100); gpio_put(LED_PIN, 0); sleep_ms(100); }\n\n    init_maps();\n\n    printf(\"&gt;&gt; START MICROMOUSE (PID REVERSA)!\\n\");\n\n    avanzar_una_celda();\n    pos_x = 0; pos_y = 1; orientacion_actual = 0;\n    visited[0][0] = 1; visited[0][1] = 1;\n\n    while (true) {\n        update_angle_global();\n\n        if ((pos_x==5 || pos_x==6) &amp;&amp; (pos_y==5 || pos_y==6)) {\n            printf(\"\\n&gt;&gt; META ALCANZADA! &lt;&lt;\\n\");\n            setMotor(0,0); setMotor(1,0);\n            while(1) { gpio_put(LED_PIN, 1); sleep_ms(200); gpio_put(LED_PIN, 0); sleep_ms(200); }\n        }\n        decidir_y_mover();\n        sleep_ms(200); \n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Proyecto/#pruebas","title":"Pruebas","text":"<ul> <li>Con ayuda del mult\u00edmetro verificamos que la energ\u00eda fluyera de manera propia, es decir, que salieran 7.4V y 3.3V en d\u00f3nde lo requiriera.</li> </ul> <p>Co n el siguiente c\u00f3digo encontramos: kp, kd, umbrales laterales y frontales:  <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdint.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/i2c.h\" \n#include \"hardware/irq.h\" \n\n// ==========================================\n// 1. PINES (CONFIGURACI\u00d3N DE TU ROBOT)\n// ==========================================\n#define LED_PIN 25\n#define I2C_PORT i2c0\n#define I2C_SDA 4\n#define I2C_SCL 5\n#define MPU6050_ADDR 0x68\n\n#define PWMA 9 \u00a0 \u00a0 \u00a0\n#define AI1 10\n#define AI2 11\n#define PWMB 15 \u00a0 \u00a0\n#define BI1 14\n#define BI2 13\n#define STBY 12\n\n#define ADC_CH_LEFT 0 \u00a0// GPIO 26\n#define ADC_CH_FRONT 1 // GPIO 27\n#define ADC_CH_RIGHT 2 // GPIO 28\n\n#define ENC_A_PIN 8 \u00a0\n#define ENC_B_PIN 16 \n\n// ==========================================\n// 2. CONSTANTES CALIBRABLES (\u00a1ACTUALIZA AQU\u00cd!)\n// ==========================================\n\nconst int BASE_SPEED = 100;\n\nconst int DEADZONE_A = 170; // Motor Izquierdo (A)\nconst int DEADZONE_B = 150; // Motor Derecho (B)\n\nuint16_t target_L = 220; \u00a0 \u00a0 \u00a0\nuint16_t target_R = 2629; \u00a0 \u00a0 \n\nconst uint16_t UMBRAL_L_EXISTE = 1500; \nconst uint16_t UMBRAL_R_EXISTE = 3500; \nconst uint16_t UMBRAL_FRONTAL = 1200; \n\nfloat Kp_Wall = 0.2f; \u00a0\nfloat Kd_Wall = 0.0f; \u00a0\nfloat prev_error_wall = 0;\n\n\n// ==========================================\n// 3. FUNCIONES DE HARDWARE ESENCIALES\n// ==========================================\n\nvoid setMotor(int motor, int pwm_val) {\n\u00a0 \u00a0 int pinPWM = (motor == 0) ? PWMA : PWMB;\n\u00a0 \u00a0 int pin1 = (motor == 0) ? AI1 : BI1; \n\u00a0 \u00a0 int pin2 = (motor == 0) ? AI2 : BI2;\n\u00a0 \u00a0 int deadzone = (motor == 0) ? DEADZONE_A : DEADZONE_B;\n\n\u00a0 \u00a0 int pwm_final = 0;\n\u00a0 \u00a0 if (pwm_val &gt; 0) pwm_final = pwm_val + deadzone;\n\u00a0 \u00a0 else if (pwm_val &lt; 0) pwm_final = pwm_val - deadzone;\n\u00a0 \u00a0 \n\u00a0 \u00a0 if (pwm_final &gt; 950) pwm_final = 950; \n\u00a0 \u00a0 if (pwm_final &lt; -950) pwm_final = -950;\n\n\u00a0 \u00a0 if (pwm_final &gt;= 0) { \n\u00a0 \u00a0 \u00a0 \u00a0 gpio_put(pin1, 0); \n\u00a0 \u00a0 \u00a0 \u00a0 gpio_put(pin2, 1); \n\u00a0 \u00a0 \u00a0 \u00a0 pwm_set_gpio_level(pinPWM, pwm_final); \n\u00a0 \u00a0 } else { \n\u00a0 \u00a0 \u00a0 \u00a0 gpio_put(pin1, 1); \n\u00a0 \u00a0 \u00a0 \u00a0 gpio_put(pin2, 0); \n\u00a0 \u00a0 \u00a0 \u00a0 pwm_set_gpio_level(pinPWM, abs(pwm_final)); \n\u00a0 \u00a0 }\n}\n\nuint16_t read_adc(int channel) {\n\u00a0 \u00a0 adc_select_input(channel);\n\u00a0 \u00a0 return adc_read();\n}\n\nvoid flash_led(int veces, int tiempo_ms) {\n\u00a0 \u00a0 for(int i=0; i&lt;veces; i++) {\n\u00a0 \u00a0 \u00a0 \u00a0 gpio_put(LED_PIN, 1); sleep_ms(tiempo_ms); \n\u00a0 \u00a0 \u00a0 \u00a0 gpio_put(LED_PIN, 0); sleep_ms(tiempo_ms); \n\u00a0 \u00a0 }\n}\n\n// \ud83d\udd25 NUEVA FUNCI\u00d3N: ESPERAR HASTA QUE SE PRESIONE UNA TECLA\nvoid wait_for_key() {\n    printf(\"\\n&gt;&gt;&gt; PRESIONA CUALQUIER TECLA (y Enter) PARA CONTINUAR &lt;&lt;&lt;\\n\");\n    // Esperar a que se presione la primera tecla\n    while(getchar() == EOF);\n\n    // Limpiar el buffer (incluyendo Enter) para la pr\u00f3xima lectura\n    int c; while ((c = getchar()) != '\\n' &amp;&amp; c != '\\r' &amp;&amp; c != EOF);\n}\n\nvoid init_all_calib() {\n\u00a0 \u00a0 // 1. Inicializaci\u00f3n Serial y espera \n\u00a0 \u00a0 stdio_init_all();\n\u00a0 \u00a0 sleep_ms(3000); \n\n\u00a0 \u00a0 // 2. LED y STBY (H-Bridge Enable)\n\u00a0 \u00a0 gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT);\n\u00a0 \u00a0 \n\u00a0 \u00a0 int pins_out[] = {AI1, AI2, BI1, BI2, STBY};\n\u00a0 \u00a0 for(int i=0; i&lt;5; i++) { gpio_init(pins_out[i]); gpio_set_dir(pins_out[i], GPIO_OUT); }\n\u00a0 \u00a0 gpio_put(STBY, 1); \n\u00a0 \u00a0 \n\u00a0 \u00a0 // 3. Configuraci\u00f3n PWM\n\u00a0 \u00a0 gpio_set_function(PWMA, GPIO_FUNC_PWM); gpio_set_function(PWMB, GPIO_FUNC_PWM);\n\u00a0 \u00a0 uint slice_A = pwm_gpio_to_slice_num(PWMA);\n\u00a0 \u00a0 uint slice_B = pwm_gpio_to_slice_num(PWMB);\n\u00a0 \u00a0 \n\u00a0 \u00a0 pwm_set_wrap(slice_A, 1000); pwm_set_enabled(slice_A, true);\n\u00a0 \u00a0 pwm_set_wrap(slice_B, 1000); pwm_set_enabled(slice_B, true);\n\u00a0 \u00a0 \n\u00a0 \u00a0 // 4. Inicializaci\u00f3n ADC\n\u00a0 \u00a0 adc_init(); \n\u00a0 \u00a0 adc_gpio_init(26); \n\u00a0 \u00a0 adc_gpio_init(27); \n\u00a0 \u00a0 adc_gpio_init(28); \n}\n\n// ==========================================\n// 4. SECUENCIAS DE CALIBRACION\n// ==========================================\n\nvoid calibracion_sensores() {\n\u00a0 \u00a0 printf(\"\\n\\n--- 1. CALIBRACION DE SENSORES ADC ---\\n\");\n\u00a0 \u00a0 flash_led(3, 200);\n\n\u00a0 \u00a0 // ----------------------------------------------------\n\u00a0 \u00a0 printf(\"\\nPASO 1: LECTURAS SIN PARED (Hueco/Lejos)\\n\");\n\u00a0 \u00a0 printf(\"Coloca el robot en un area abierta, sin paredes cerca.\\n\");\n\u00a0 \u00a0 wait_for_key(); // Espera la confirmaci\u00f3n del usuario\n\n\u00a0 \u00a0 uint16_t l_far = read_adc(ADC_CH_LEFT);\n\u00a0 \u00a0 uint16_t f_far = read_adc(ADC_CH_FRONT);\n\u00a0 \u00a0 uint16_t r_far = read_adc(ADC_CH_RIGHT);\n\u00a0 \u00a0 printf(\"LEJOS -&gt; L: %u | F: %u | R: %u\\n\", l_far, f_far, r_far);\n\n\u00a0 \u00a0 // ----------------------------------------------------\n\u00a0 \u00a0 printf(\"\\nPASO 2: LECTURAS EN EL CENTRO (Objetivo PID)\\n\");\n\u00a0 \u00a0 printf(\"Coloca el robot perfectamente CENTRADO entre dos paredes laterales.\\n\");\n\u00a0 \u00a0 wait_for_key(); // Espera la confirmaci\u00f3n del usuario\n\n\u00a0 \u00a0 uint16_t l_target_val = read_adc(ADC_CH_LEFT);\n\u00a0 \u00a0 uint16_t r_target_val = read_adc(ADC_CH_RIGHT);\n\u00a0 \u00a0 printf(\"TARGET -&gt; L: %u | R: %u\\n\", l_target_val, r_target_val);\n\u00a0 \u00a0 printf(\"\u2705 target_L = %u, target_R = %u\\n\", l_target_val, r_target_val);\n\u00a0 \u00a0 \n\u00a0 \u00a0 // ----------------------------------------------------\n\u00a0 \u00a0 printf(\"\\nPASO 3: LECTURAS EN EL LIMITE (Umbrales de Existencia)\\n\");\n\u00a0 \u00a0 printf(\"Coloca el robot donde el sensor lateral Apenas detecta la pared.\\n\");\n\u00a0 \u00a0 wait_for_key(); // Espera la confirmaci\u00f3n del usuario\n\n\u00a0 \u00a0 uint16_t l_limite = read_adc(ADC_CH_LEFT);\n\u00a0 \u00a0 uint16_t r_limite = read_adc(ADC_CH_RIGHT);\n\u00a0 \u00a0 uint16_t f_cerca = read_adc(ADC_CH_FRONT);\n\u00a0 \u00a0 printf(\"LIMITES -&gt; L: %u | R: %u | F: %u\\n\", l_limite, r_limite, f_cerca);\n\u00a0 \u00a0 printf(\"\u2705 UMBRAL_L_EXISTE, UMBRAL_R_EXISTE, UMBRAL_FRONTAL.\\n\");\n\u00a0 \u00a0 \n\u00a0 \u00a0 printf(\"\\n\u00a1Actualiza la Seccion 2 con estos valores antes de la prueba PID!\\n\");\n}\n\nvoid prueba_control_pid() {\n\u00a0 \u00a0 // (La prueba PID no requiere cambios de tiempo, ya que est\u00e1 en movimiento)\n\u00a0 \u00a0 printf(\"\\n\\n--- 2. PRUEBA DE CONTROL PID EN AVANCE ---\\n\");\n\u00a0 \u00a0 printf(\"Kp_Wall: %.2f | Kd_Wall: %.2f\\n\", Kp_Wall, Kd_Wall);\n\u00a0 \u00a0 printf(\"Coloca el robot CENTRADO entre paredes. Avanzara por 4 segundos.\\n\");\n\u00a0 \u00a0 flash_led(5, 300);\n\n\u00a0 \u00a0 absolute_time_t start_time = get_absolute_time();\n\u00a0 \u00a0 prev_error_wall = 0;\n\n\u00a0 \u00a0 while (absolute_time_diff_us(start_time, get_absolute_time()) &lt; 4000000) { \n\u00a0 \u00a0 \u00a0 \u00a0 uint16_t val_L = read_adc(ADC_CH_LEFT);\n\u00a0 \u00a0 \u00a0 \u00a0 uint16_t val_R = read_adc(ADC_CH_RIGHT);\n\n\u00a0 \u00a0 \u00a0 \u00a0 bool wall_L = (val_L &lt; UMBRAL_L_EXISTE); \n\u00a0 \u00a0 \u00a0 \u00a0 bool wall_R = (val_R &lt; UMBRAL_R_EXISTE);\n\n\u00a0 \u00a0 \u00a0 \u00a0 float error = 0;\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 if (wall_L &amp;&amp; wall_R) error = (float)(val_L - target_L) - (float)(val_R - target_R);\n\u00a0 \u00a0 \u00a0 \u00a0 else if (wall_L) error = 2.0f * (float)(val_L - target_L); \u00a0\n\u00a0 \u00a0 \u00a0 \u00a0 else if (wall_R) error = -2.0f * (float)(val_R - target_R); \n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 float correction = (error * Kp_Wall) + ((error - prev_error_wall) * Kd_Wall);\n\u00a0 \u00a0 \u00a0 \u00a0 prev_error_wall = error;\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 if (correction &gt; 200) correction = 200; \n\u00a0 \u00a0 \u00a0 \u00a0 if (correction &lt; -200) correction = -200;\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 setMotor(0, BASE_SPEED + (int)correction); \n\u00a0 \u00a0 \u00a0 \u00a0 setMotor(1, BASE_SPEED - (int)correction); \n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 sleep_ms(10); \n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 setMotor(0, 0); \n\u00a0 \u00a0 setMotor(1, 0);\n\u00a0 \u00a0 printf(\"Prueba PID finalizada. Revisa el movimiento y ajusta Kp/Kd.\\n\");\n}\n\n\n// ==========================================\n// 5. MAIN DE CALIBRACION\n// ==========================================\nint main() {\n\u00a0 \u00a0 init_all_calib();\n\u00a0 \u00a0 \n\u00a0 \u00a0 printf(\"--- MICROMOUSE CALIBRACION ---\\n\");\n\u00a0 \u00a0 \n\u00a0 \u00a0 while (true) {\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"\\n----------------------------------------\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"Selecciona una opcion:\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"1. \ud83d\udcd0 Calibracion de Sensores (Targets y Umbrales)\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"2. \ud83c\udfce\ufe0f Prueba de Control PID (Ajustar Kp y Kd)\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"3. \ud83d\uded1 Salir\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"Ingresa tu eleccion y presiona Enter: \");\n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 char choice = getchar();\n\u00a0 \u00a0 \u00a0 \u00a0 int c; while ((c = getchar()) != '\\n' &amp;&amp; c != '\\r' &amp;&amp; c != EOF); \n\u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 \u00a0 switch (choice) {\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case '1':\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 calibracion_sensores();\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case '2':\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 prueba_control_pid();\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 case '3':\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 printf(\"Saliendo. Parpadeo de LED.\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 setMotor(0,0); setMotor(1,0); \n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 while(1) { flash_led(1, 500); }\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 default:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 printf(\"Opcion no valida.\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 break;\n\u00a0 \u00a0 \u00a0 \u00a0 }\n\u00a0 \u00a0 }\n\u00a0 \u00a0 return 0;\n}\n</code></pre> Obteniendo los siguientes resultados: <pre><code>target_L = 1928;        \n\nuint16_t target_R = 2552;      \n\n\n\nconst uint16_t UMBRAL_L_EXISTE = 2535;\n\nconst uint16_t UMBRAL_R_EXISTE = 2324;\n\nconst uint16_t UMBRAL_FRONTAL = 2250;\n\n\n\nfloat Kp_Wall = 0.2f;  \n\nfloat Kd_Wall = 0.4f; \n</code></pre></p>"},{"location":"Sistemas%20Embebidos/Proyecto/#metricas","title":"M\u00e9tricas","text":"<ul> <li> <p>Tiene una tolerancia de 2 grados.</p> </li> <li> <p>El \u00e1rea muerta de motores.</p> </li> <li> <p>Encoder del motor A, sin funcionar.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Proyecto/#decisiones-y-rationale","title":"Decisiones y rationale","text":"<p>-Usa la l\u00f3gica DFS Greedy, que indica que si no ha conocdio una celda se debe de dirigir hacia ella, y tiene la preferencia: Derecha &gt; Frente &gt; Izquierda, en  caso de que se encuentre con paredes nuevas. Proximamente, considerabamos utilizar la l\u00f3gica Food Fill que indicaria el numero menor de distancia hacia el centro.</p>"},{"location":"Sistemas%20Embebidos/Proyecto/#lecciones-aprendidas","title":"Lecciones aprendidas","text":"<ul> <li>Uno debe de aprender a pedir ayuda cuando lo necesita y a\u00fan tenemos un largo camino para aprender de la elecci\u00f3n de materiales y de dise\u00f1os para el motor. As\u00ed mismo, nosotros aprendimos a como tabajar en equipo, dividir tareas, al uso de kp y kd, y que la regulaci\u00f3n de la velocidad importa bastante. Aprendimos bastante sobre el ruido el\u00e9ctrico y que no es lo \u00fanico que afectan las lecturas, el funcionamiento de diferentes sensores y como la luz es clave para un sensor. Adem\u00e1s, de como un capacitor puede llegar a ser nuestro mejor amogo. Pero como conclsui\u00f3n, trabajar duro no significa trabajar mejor, y que el esfuerzo es lo \u00fanico que te lleva al \u00e9xito.</li> </ul>"},{"location":"Sistemas%20Embebidos/Proyecto/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea1/","title":"\ud83e\udd16 Tarea 1: Tabla comparativa","text":"<p>Garcia Cortez Juan David \u00b7  Sistemas Embebidos 1  \u00b7  25/08/2025.</p> No. Microcontrolador Perif\u00e9ricos Memoria Ecosistema Costos Arquitectura Velocidad de Trabajo 01 ESP32 (Espressif) 45 GPIO programables, SPI, I2C, I2S, UART, PWM, ADC, DAC, RMT, SD/MMC, CAN, sensores t\u00e1ctiles, Hall sensor 512 KB de SRAM interna, 448 KB de ROM, memoria Flash externa Compatible con Arduino, ESP-IDF, MicroPython, FreeRTOS $120 - $200 MXN Xtensa LX6 (32 bits, dual core) Hasta 240 MHz 02 Raspberry Pi Pico (RP2040) 26 GPIO, SPI, I2C, UART, PWM, ADC, temporizadores 264 KB de SRAM, memoria Flash externa (2 MB t\u00edpica) Compatible con C/C++, MicroPython, CircuitPython $100 - $150 MXN ARM Cortex-M0+ (32 bits, dual core) Hasta 133 MHz 03 STM32F103C8T6 37 GPIO, SPI, I2C, USART, PWM, ADC, DAC, temporizadores, CAN, USB 20 KB SRAM, 64 KB Flash Compatible con STM32Cube, Arduino, Mbed, PlatformIO $60 - $120 MXN ARM Cortex-M3 (32 bits, single core) Hasta 72 MHz 04 ATmega328 23 GPIO, SPI, I2C, UART, PWM, ADC, temporizadores 2 KB SRAM, 32 KB Flash, 1 KB EEPROM Compatible con Arduino, AVR-GCC $50 - $90 MXN AVR (8 bits, single core) Hasta 20 MHz <p>Perif\u00e9ricos: M\u00f3dulos Integrados que permiten interactuar con el mundo f\u00edsico.</p>"},{"location":"Sistemas%20Embebidos/Tarea1/#conclusiones","title":"Conclusiones","text":"<ul> <li>Para un proyecto como una conosla de mezclas de m\u00fasica, la ESP32, resulta como la mejor opci\u00f3n, dado a su versatilidad y conectividad WiFi/Bluetooth integrado, facilitando la integraci\u00f3n y comunicaci\u00f3n con otros dispositivos. La Raspberry Pi Pico tambi\u00e9n es una opci\u00f3n flexible y potente, especialmente si se requiere procesamiento en paralelo o facilidad de programaci\u00f3n con MicroPython. Seguido de, tenemos la STM32F103C8T6 que es ideal para apliacaciones m\u00e1s industriales,pero no cuenta con una conectividad inal\u00e1mbrica, y su programaci\u00f3n puede llegar a ser m\u00e1s compleja. Finalmente, el ATmega328P puede quedarse corto para este tipo de proyectos, ya que se dificulta al manejar m\u00faltiples dispositivos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/","title":"\ud83e\udd16 Tarea 2: Outputs B\u00e1sicos","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea2/#contador-binario-4-bits","title":"Contador Binario 4 bits","text":"<ul> <li>En 4 leds debe mostrarse cada segundo de la presentaci\u00f3n binaria del 0 al 15</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define Led1 6   // (Less Significant Bit)\n#define Led2 7   // \n#define Led3 8   // \n#define Led4 9   // (Most Significant Bit)\n\nint main() {\n    // M\u00e1scara con los 4 LEDs\n    const uint32_t Mascara = (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4); //Aqui se define que leds vamos a ocupar\n\n    gpio_init_mask(Mascara); // Inicializamos los pines\n    gpio_set_dir_masked(Mascara, Mascara); // Definimos todos como salida, utilizando 1u que se mostro arriba\n\n    int contador = 0;  // Iniciamos el contador en 0\n\n    while (true) {\n        // Poner en LEDs el valor del contador\n        gpio_put_masked(Mascara, (contador &lt;&lt; Led1));\n\n        sleep_ms(1000); // 1 segundo\n\n        contador++;\n        if (contador &gt; 15) { // Reinicia al llegar a 15\n            contador = 0;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea2/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea2/#barrido-de-leds","title":"Barrido de leds","text":"<ul> <li>Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n#include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n\n#define Led1 6\n#define Led2 7\n#define Led3 8\n#define Led4 9\n#define Led5 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5)); // Configura los pines como salida\n\n\n    int posicion = 6;\n\n    int direccion = 1; // 1 para derecha, -1 para izquierda\n\n    while (true)\n    {\n        gpio_put_masked(Mascara, (1u &lt;&lt; posicion)); // Enciende el LED en la posici\u00f3n actual\n        sleep_ms(200);                             // Pausa de 200 ms\n\n        posicion += direccion; // Actualiza la posici\u00f3n\n        if (posicion == Led5) direccion = -1;\n        else if (posicion == Led1) direccion = 1;\n\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea2/#video_1","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea2/#secuencia-en-codigo-gray","title":"Secuencia en codigo Gray","text":"<ul> <li>Mostrar la secuencia del 0 al 15 en forma de c\u00f3digo Gray</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/#codigo_2","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define Led1 6   // (LSB)\n#define Led2 7   \n#define Led3 8   \n#define Led4 9   // (MSB)\n\nint main() {\n    const uint32_t Mascara = (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4);\n\n    gpio_init_mask(Mascara);\n    gpio_set_dir_masked(Mascara, Mascara);\n\n    int contador = 0;\n\n    while (true) {\n        // Convertir de binario a Gray\n        int gray = contador ^ (contador &gt;&gt; 1);\n\n        // Mandar a los LEDs\n        gpio_put_masked(Mascara, (gray &lt;&lt; Led1));\n\n        sleep_ms(1000);\n\n        contador++;\n        if (contador &gt; 15) {\n            contador = 0;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea2/#video_2","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea3/","title":"\ud83e\udd16 Tarea 3: Inputs","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea3/#compuertas-basicas-and-or-xor-con-2-botones","title":"Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<ul> <li>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea3/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n// #include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n#define BotonX 4\n#define BotonY 5\n#define LedX 6\n#define LedY 7\n#define LedZ_AND 8\n#define LedZ_OR 9\n#define LedZ_XOR 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; BotonX | 1u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (0u &lt;&lt; BotonX | 0u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR)); // Configura los pines como salida\n    gpio_pull_up(BotonX);                                                                                                                    // Activa la resistencia pull-up interna del pin 4\n    gpio_pull_up(BotonY);\n\n    while (true)\n    {\n        int Entrada_X = !gpio_get(BotonX);\n        int Entrada_Y = !gpio_get(BotonY);\n        int Salida_AND, Salida_OR, Salida_XOR;\n\n        Salida_AND = Entrada_X &amp; Entrada_Y; // Pin 8 = Pin 4 AND Pin 5\n        Salida_OR = Entrada_X | Entrada_Y;  // Pin 9 = Pin 4 OR Pin 5\n        Salida_XOR = Entrada_X ^ Entrada_Y; // Pin 10 = Pin 4 XOR Pin 5\n\n        gpio_put_masked(Mascara, (1 &lt;&lt; 11) | (Entrada_X &lt;&lt; LedX) | (Entrada_Y &lt;&lt; LedY) | (Salida_AND &lt;&lt; LedZ_AND) | (Salida_OR &lt;&lt; LedZ_OR) | (Salida_XOR &lt;&lt; LedZ_XOR));\n        sleep_ms(100); // Pausa de 100 ms\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea3/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea3/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea3/#selector-ciclico-de-5-leds-con-avanceretroceso","title":"Selector c\u00edclico de 5 LEDs con avance/retroceso","text":"<ul> <li>Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21924\u21920) y otro RETROCEDE (0\u21924\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea3/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n// #include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n#define BotonX 4\n#define BotonY 5\n#define Led1 6\n#define Led2 7\n#define Led3 8\n#define Led4 9\n#define Led5 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; BotonX | 1u &lt;&lt; BotonY | 1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (0u &lt;&lt; BotonX | 0u &lt;&lt; BotonY | 1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5)); // Configura los pines como salida\n    gpio_pull_up(BotonX);                                                                                                                    // Activa la resistencia pull-up interna del pin 4\n    gpio_pull_up(BotonY);\n\n    int posicion = 6;\n    bool presionado = false;\n\n    while (true)\n    {\n        int Boton_Izq = !gpio_get(BotonX);\n        int Boton_Der = !gpio_get(BotonY);\n\n        if (Boton_Izq == 1 &amp;&amp; presionado == false)\n        {\n            presionado = true;\n            if (posicion == 6)\n                posicion = 11;\n            posicion--;\n        }\n        if (Boton_Der == 1 &amp;&amp; presionado == false)\n        {\n            presionado = true;\n            if (posicion == 10)\n                posicion = 5;\n            posicion++;\n        }\n        if (Boton_Izq == 0 &amp;&amp; Boton_Der == 0)\n            presionado = false;\n        gpio_put_masked(Mascara, (1u &lt;&lt; posicion)); // Enciende el LED en la posici\u00f3n actual\n        sleep_ms(10);                              // Pausa de 100 ms\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea3/#esquematico_1","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea3/#video_1","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea4/","title":"\ud83e\udd16 Tarea 4: Pong","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea4/#programar-un-mini-pong-con-5-leds-en-linea-y-2-botones-usando-interrupciones-isr-para-registrar-el-golpe-del-jugador-exactamente-cuando-la-pelota-un-led-encendido-llega-al-extremo-de-su-lado","title":"Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.","text":""},{"location":"Sistemas%20Embebidos/Tarea4/#reglas-del-juego","title":"Reglas del juego","text":"<ul> <li> <p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> </li> <li> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> </li> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> <li> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea4/#codigo","title":"C\u00f3digo","text":"<pre><code>// tarea4.c\n\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n// Pines\n#define P1 4\n#define P2 5\n#define WIN1 6\n#define LED1 7\n#define LED2 8\n#define LED3 9\n#define LED4 10\n#define LED5 11\n#define WIN2 12\n\n// Flags de interrupci\u00f3n\nvolatile bool flag_p1 = false;\nvolatile bool flag_p2 = false;\n\n// Funci\u00f3n para parpadear LED ganador\nvoid parpadear_led(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\n// Callback de interrupci\u00f3n\nvoid gpio_callback(uint gpio, uint32_t events) {\n    if (events &amp; GPIO_IRQ_EDGE_RISE) {\n        if (gpio == P1) flag_p1 = true;\n        else if (gpio == P2) flag_p2 = true;\n    }\n}\n\nint main() {\n    // Inicializar LEDs\n    const uint32_t LED_MASK = (1u &lt;&lt; WIN1) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) |\n                               (1u &lt;&lt; LED4) | (1u &lt;&lt; LED5) | (1u &lt;&lt; WIN2);\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_masked(LED_MASK, LED_MASK);\n\n    // Inicializar botones\n    gpio_init(P1); gpio_set_dir(P1, GPIO_IN); gpio_pull_down(P1); //tambien tiene pulldown externo\n    gpio_init(P2); gpio_set_dir(P2, GPIO_IN); gpio_pull_down(P2);\n    gpio_set_irq_enabled_with_callback(P1, GPIO_IRQ_EDGE_RISE, true, &amp;gpio_callback);\n    gpio_set_irq_enabled(P2, GPIO_IRQ_EDGE_RISE, true);\n\n    int ultima_direccion = 1; // 1: derecha (jugador 2), -1: izquierda (jugador 1)\n    bool primer_jugada = true; // &lt;--- NUEVO\n\n    while (true) {\n        gpio_put_masked(LED_MASK, 0); // Apagar todos los LEDs\n        gpio_put(LED3, 1); // Encender LED3 del medio\n\n        // Esperar a que se presione cualquier bot\u00f3n antes de iniciar la secuencia\n        while (gpio_get(P1) == 0 &amp;&amp; gpio_get(P2) == 0) {\n            sleep_ms(10);\n        }\n\n        // Apagar LED3 antes de iniciar la secuencia\n        gpio_put(LED3, 0);\n\n        int direccion_inicial;\n        if (primer_jugada) {\n            // Primera jugada: direcci\u00f3n hacia el jugador que NO presion\u00f3 el bot\u00f3n\n            if (gpio_get(P1) == 1) {\n                direccion_inicial = 1;  // P1 presion\u00f3, va hacia P2\n            } else if (gpio_get(P2) == 1) {\n                direccion_inicial = -1; // P2 presion\u00f3, va hacia P1\n            } else {\n                direccion_inicial = ultima_direccion; // Por si acaso\n            }\n            primer_jugada = false;\n        } else {\n            // Siguientes jugadas: direcci\u00f3n hacia el ganador anterior\n            direccion_inicial = ultima_direccion;\n        }\n\n        int posicion = LED3;\n        int direccion = direccion_inicial;\n        flag_p1 = false;\n        flag_p2 = false;\n\n        int prev_p1 = 1, prev_p2 = 1;\n\n        while (1) {\n            gpio_put_masked(LED_MASK, 0);\n\n            if (posicion &gt;= LED1 &amp;&amp; posicion &lt;= LED5) {\n                gpio_put(posicion, 1);\n            }\n            sleep_ms(400);\n\n            int curr_p1 = gpio_get(P1);\n            int curr_p2 = gpio_get(P2);\n\n            if (posicion == LED1 &amp;&amp; prev_p1 == 1 &amp;&amp; curr_p1 == 0) {\n                direccion = 1;\n            } else if (posicion == LED5 &amp;&amp; prev_p2 == 1 &amp;&amp; curr_p2 == 0) {\n                direccion = -1;\n            }\n\n            prev_p1 = curr_p1;\n            prev_p2 = curr_p2;\n\n            // Verificar victoria\n            if (posicion == WIN1) {\n                gpio_put_masked(LED_MASK, 0);\n                parpadear_led(WIN2);\n                ultima_direccion = 1; // Ahora la siguiente ronda va hacia jugador 2\n                break;\n            } else if (posicion == WIN2) {\n                gpio_put_masked(LED_MASK, 0);\n                parpadear_led(WIN1);\n                ultima_direccion = -1; // Ahora la siguiente ronda va hacia jugador 1\n                break;\n            }\n\n            posicion += direccion;\n        }\n        sleep_ms(500); // Espera antes de reiniciar el juego\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea4/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea4/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea5/","title":"\ud83e\udd16 Tarea 5: Ejercicio de Medici\u00f3n.","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  15/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea5/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<ul> <li> <p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> </li> <li> <p>Periodo promedio y tolerancia.</p> </li> <li> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS.  Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#codigo","title":"C\u00f3digo","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 6\nstatic const int BLINK_MS = 100;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea5/#imagen-del-osciloscopio","title":"Imagen del Osciloscopio","text":"<ul> <li>El osciloscopio se encuentra con una escala del 50X, a una posici\u00f3n de 2.58 microsegundos. Una diferencia de tiempo de 100 microsegundos y una diferencia de voltaje de 37.19 mV</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<ul> <li> <p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> </li> <li> <p>Usa rearme acumulativo.</p> </li> <li> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico.</p> </li> <li> <p>Con el osciloscopio, mide y registra para cada modo:</p> </li> <li> <p>Periodo promedio y desviaci\u00f3n respecto al nominal.</p> </li> <li> <p>Jitter pico-a-pico y/o RMS.</p> </li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#codigo-con-microsegundos","title":"C\u00f3digo con microsegundos","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       6\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 400u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea5/#imagen-del-osciloscopio_1","title":"Imagen del Osciloscopio","text":""},{"location":"Sistemas%20Embebidos/Tarea5/#codigo-con-ciclos","title":"C\u00f3digo con Ciclos","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       6\n#define ALARM_NUM     0  // usaremos la alarma 0\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\n#define CLK_SYS_HZ    150000000u\nstatic volatile uint32_t next_deadline;   \nstatic volatile uint32_t intervalo_ciclos = (CLK_SYS_HZ /1000000u)* 400000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_ciclos;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    timer_hw-&gt;timerctrl = TIMER_TIMERCTRL_CLK_SYS_BITS;\n\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_cycles = timer_hw-&gt;timerawl;          \n    next_deadline = now_cycles + intervalo_ciclos;         \n\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea5/#imagen-del-osciloscopio_2","title":"Imagen del Osciloscopio","text":"<ul> <li>Podemos concluir que el uso de los ciclos es m\u00e1s exacto y preciso para analizar se\u00f1ales r\u00e1pidas y medir variaciones entre ciclos individuales. Ya que en ambos casos se utilizaron 400 milisegundos, pero notamos que la diferencia de tiempo fue m\u00e1s cercana al valor te\u00f3rico en el caso de los ciclos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#esquematico-utilizado-en-la-practica","title":"Esquem\u00e1tico Utilizado en la Pr\u00e1ctica","text":""},{"location":"Sistemas%20Embebidos/Tarea6/","title":"\ud83e\udd16 Tarea 6: Ejercicios de Programaci\u00f3n","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  16/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea6/#ejercicio-1","title":"Ejercicio 1","text":"<ul> <li>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea6/#codigo-que-debia-funcionar","title":"C\u00f3digo que deb\u00eda funcionar","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     6   \n#define LED1_PIN     7\n#define LED2_PIN     8\n#define LED3_PIN     9                     \n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n#define ALARM3_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM3_NUM)\n\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us, next2_us, next3_us;\nstatic const uint32_t INTERVALO0_US = 250u;\nstatic const uint32_t INTERVALO1_US = 400u;\nstatic const uint32_t INTERVALO2_US = 500u;\nstatic const uint32_t INTERVALO3_US = 800u;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\n// ISR para ALARM2\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\n// ISR para ALARM3\nstatic void on_alarm3_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM3_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n    next3_us += INTERVALO3_US;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n}\n\nint main() {\n\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n    gpio_init(LED3_PIN);\n    gpio_set_dir(LED3_PIN, GPIO_OUT);\n    gpio_put(LED3_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    // Programa ambas alarmas\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n    irq_set_exclusive_handler(ALARM3_IRQ, on_alarm3_irq);\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Habilita ambas IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n    irq_set_enabled(ALARM3_IRQ, true);\n\n    // Bucle principal: todo el parpadeo ocurre en las ISRs\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea6/#codigo-que-funciono","title":"C\u00f3digo que funcion\u00f3","text":"<pre><code>// Tres LEDs con alarmas del timer + un LED controlado por polling en el main loop\n// - ALARM0 controla el LED en GPIO 6\n// - ALARM1 controla el LED en GPIO 7\n// - ALARM2 controla el LED en GPIO 8\n// - GPIO 9 se controla por polling en el bucle principal\n\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n// Definici\u00f3n de pines para los LEDs\n#define LED0_PIN     6  // LED en GPIO 6 (ALARM0)\n#define LED1_PIN     7  // LED en GPIO 7 (ALARM1)\n#define LED2_PIN     8  // LED en GPIO 8 (ALARM2)\n#define LED3_PIN     9  // LED en GPIO 9 (polling)\n\n// N\u00fameros de alarma (solo existen 0, 1, 2)\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n\n// IRQs para cada alarma\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us, next2_us;\nstatic const uint32_t INTERVALO0_US = 250000u;  // 250 ms\nstatic const uint32_t INTERVALO1_US = 400000u;  // 400 ms\nstatic const uint32_t INTERVALO2_US = 600000u;  // 600 ms\nstatic const uint32_t INTERVALO3_US = 1000000u; // 1000 ms\n\n// Para el LED controlado por polling\nstatic volatile uint32_t next_poll_us = 0;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\n\n// ISR para ALARM2\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\n\nint main() {\n    // Configuraci\u00f3n de los pines de los LEDs\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n    gpio_init(LED3_PIN);\n    gpio_set_dir(LED3_PIN, GPIO_OUT);\n    gpio_put(LED3_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines para cada alarma\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next_poll_us = now_us + INTERVALO3_US;\n\n    // Programa las tres alarmas disponibles\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | \n                                   (1u &lt;&lt; ALARM2_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | \n                                 (1u &lt;&lt; ALARM2_NUM));\n\n    // Habilita todas las IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n\n    // Bucle principal: controlamos el cuarto LED por polling\n    while (true) {\n        uint32_t current_time = timer_hw-&gt;timerawl;\n\n        // Control por polling del cuarto LED\n        if ((int32_t)(current_time - next_poll_us) &gt;= 0) {\n            sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n            next_poll_us += INTERVALO3_US;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea6/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea6/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea6/#ejercicio-2","title":"Ejercicio 2","text":"<ul> <li>Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea6/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n// Pines\n#define P1 4\n#define P2 5\n#define WIN1 6\n#define LED1 7\n#define LED2 8\n#define LED3 9\n#define LED4 10\n#define LED5 11\n#define WIN2 12\n#define BTN_SLOW 14\n#define BTN_FAST 15\n\n#define ALARM0_NUM 0\n#define ALARM0_IRQ timer_hw-&gt;intr\n\n// LEDs\nconst uint LEDS[] = {WIN1, LED1, LED2, LED3, LED4, LED5, WIN2};\n\n// Estado del juego\nvolatile int posicion = LED3;\nvolatile int direccion = 1;\nvolatile bool flag_p1 = false;\nvolatile bool flag_p2 = false;\nvolatile bool flag_slow = false;\nvolatile bool flag_fast = false;\nvolatile bool juego_activo = true;\n\n// Intervalo de movimiento en \u00b5s\nvolatile uint32_t intervalo_us = 200000;\nvolatile uint32_t next_alarm_us = 0;\n\n// Parpadeo de LED ganador\nvoid parpadear_led(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(300);\n        gpio_put(led, 0);\n        sleep_ms(300);\n    }\n}\n\n// Interrupciones GPIO\nvoid gpio_callback(uint gpio, uint32_t events) {\n    if (events &amp; GPIO_IRQ_EDGE_RISE) {\n        if (gpio == P1) flag_p1 = true;\n        else if (gpio == P2) flag_p2 = true;\n        else if (gpio == BTN_SLOW) flag_slow = true;\n        else if (gpio == BTN_FAST) flag_fast = true;\n    }\n}\n\n// Interrupci\u00f3n de ALARM0\nvoid on_alarm0_irq() {\n    // Limpiar flag\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n\n    if (!juego_activo) return;\n\n    // Apagar todos los LEDs\n    for (int i = 0; i &lt; 7; i++) gpio_put(LEDS[i], 0);\n\n    // Encender LED actual\n    gpio_put(posicion, 1);\n\n    // Cambiar direcci\u00f3n solo si el LED est\u00e1 en el extremo\n    if (posicion == LED1) {\n        if (flag_p1) {\n            direccion = 1;\n            flag_p1 = false;\n        }\n    } else if (posicion == LED5) {\n        if (flag_p2) {\n            direccion = -1;\n            flag_p2 = false;\n        }\n    }\n\n    // Ajustar velocidad\n    if (flag_slow) {\n        intervalo_us += 50000;\n        if (intervalo_us &gt; 1000000) intervalo_us = 1000000;\n        flag_slow = false;\n    }\n    if (flag_fast) {\n        if (intervalo_us &gt; 50000) intervalo_us -= 50000;\n        flag_fast = false;\n    }\n\n    // Verificar victoria\n    if (posicion == WIN1) {\n        parpadear_led(WIN2);\n        juego_activo = false;\n        direccion = 1;\n        return;\n    } else if (posicion == WIN2) {\n        parpadear_led(WIN1);\n        juego_activo = false;\n        direccion = -1;\n        return;\n    }\n\n    // Mover LED\n    posicion += direccion;\n\n    // Reprogramar alarma\n    next_alarm_us += intervalo_us;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next_alarm_us;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar LEDs\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], GPIO_OUT);\n        gpio_put(LEDS[i], 0);\n    }\n\n    // Inicializar botones\n    gpio_init(P1); gpio_set_dir(P1, GPIO_IN); gpio_pull_up(P1);\n    gpio_init(P2); gpio_set_dir(P2, GPIO_IN); gpio_pull_up(P2);\n    gpio_init(BTN_SLOW); gpio_set_dir(BTN_SLOW, GPIO_IN); gpio_pull_up(BTN_SLOW);\n    gpio_init(BTN_FAST); gpio_set_dir(BTN_FAST, GPIO_IN); gpio_pull_up(BTN_FAST);\n\n    // Configurar interrupciones GPIO\n    gpio_set_irq_enabled_with_callback(P1, GPIO_IRQ_EDGE_RISE, true, &amp;gpio_callback);\n    gpio_set_irq_enabled(P2, GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN_SLOW, GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN_FAST, GPIO_IRQ_EDGE_RISE, true);\n\n    // Configurar TIMER\n    timer_hw-&gt;source = 0u;\n    irq_set_exclusive_handler(timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM), on_alarm0_irq);\n    irq_set_enabled(timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM), true);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM0_NUM);\n\n    while (true) {\n        // Reiniciar estado\n        posicion = LED3;\n        juego_activo = true;\n        intervalo_us = 200000;\n\n        // Programar primera alarma\n        next_alarm_us = timer_hw-&gt;timerawl + intervalo_us;\n        timer_hw-&gt;alarm[ALARM0_NUM] = next_alarm_us;\n\n        // Esperar fin del juego\n        while (juego_activo) {\n            tight_loop_contents();\n        }\n\n        sleep_ms(1000); // Espera antes de reiniciar\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea6/#esquematico_1","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea6/#video_1","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea7.1/","title":"\ud83e\udd16 Tarea 7.1: PWM","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/10/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#control-de-duty-cycle-motor-dc","title":"Control de Duty Cycle \u2014 Motor DC","text":"<ul> <li>Entregable: </li> <li>Implementar un circuito con un motor DC controlado mediante PWM  variando el duty cycle. </li> <li> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> </li> <li> <p>Documentar:</p> </li> <li> <p>Valores de duty usados, con el porque.</p> </li> <li>No olvidar que el microcontrolador no entrega suficiente potencia, se debe usar un puente H o driver de motor para conectar el motor DC.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define ENA 2       // Pin PWM (velocidad del motor)\n#define IN1 3       // Direcci\u00f3n (H-Bridge)\n#define IN2 4       // Direcci\u00f3n (H-Bridge)\n#define BTN_UP 14   // Bot\u00f3n para subir velocidad\n#define BTN_DOWN 15 // Bot\u00f3n para bajar velocidad\n\n#define F_PWM_HZ 2000   // Frecuencia de PWM\n#define TOP 1023        // Resoluci\u00f3n de 10 bits (0\u20131023)\n\n// Valores de duty cycle (equivalentes a 40%, 60% y 80%)\nconst uint16_t duty_values[] = {410, 615, 820};\n\nint speed_index = 1;  // Empezar en el valor medio (60%)\n\nbool last_up = true;\nbool last_down = true;\n\n// -----------------------------------------------------\n// Funci\u00f3n para establecer la velocidad del motor (duty cycle)\n// -----------------------------------------------------\nvoid set_motor_speed(uint slice, uint chan, uint16_t duty) {\n    // Si el duty es bajo, hacer un \u201carranque forzado\u201d al 100%\n    if (duty &gt; 0 &amp;&amp; duty &lt;= 410) { // equivalente al 40%\n        pwm_set_chan_level(slice, chan, TOP); // duty = 100%\n        sleep_ms(100);\n    }\n\n    pwm_set_chan_level(slice, chan, duty);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configurar pines de direcci\u00f3n\n    gpio_init(IN1);\n    gpio_set_dir(IN1, GPIO_OUT);\n    gpio_put(IN1, 1);\n\n    gpio_init(IN2);\n    gpio_set_dir(IN2, GPIO_OUT);\n    gpio_put(IN2, 0);\n\n    // Configurar botones\n    gpio_init(BTN_UP);\n    gpio_set_dir(BTN_UP, GPIO_IN);\n    gpio_pull_up(BTN_UP);\n\n    gpio_init(BTN_DOWN);\n    gpio_set_dir(BTN_DOWN, GPIO_IN);\n    gpio_pull_up(BTN_DOWN);\n\n    // Configurar PWM\n    gpio_set_function(ENA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(ENA);\n    uint chan  = pwm_gpio_to_channel(ENA);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    // Iniciar en velocidad media\n    set_motor_speed(slice, chan, duty_values[speed_index]);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        bool up_now = gpio_get(BTN_UP);\n        bool down_now = gpio_get(BTN_DOWN);\n\n        // Bot\u00f3n UP\n        if (last_up &amp;&amp; !up_now) {\n            sleep_ms(50);\n            if (!gpio_get(BTN_UP)) {\n                if (speed_index &lt; 2) speed_index++;\n                set_motor_speed(slice, chan, duty_values[speed_index]);\n            }\n        }\n\n        // Bot\u00f3n DOWN\n        if (last_down &amp;&amp; !down_now) {\n            sleep_ms(50);\n            if (!gpio_get(BTN_DOWN)) {\n                if (speed_index &gt; 0) speed_index--;\n                set_motor_speed(slice, chan, duty_values[speed_index]);\n            }\n        }\n\n        last_up = up_now;\n        last_down = down_now;\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#valores-de-duty-usados","title":"Valores de duty usados","text":"<ul> <li> <p>410 / 1023 \u00d7 100 \u2248 40%</p> </li> <li> <p>615 / 1023 \u00d7 100 \u2248 60%</p> </li> <li> <p>820 / 1023 \u00d7 100 \u2248 80%</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea7.1/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea7.2/","title":"\ud83e\udd16 Tarea 7.2: PWM","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/10/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#control-con-frecuencia-buzzer","title":"Control con frecuencia buzzer","text":"<ul> <li> <p>Entregable:</p> </li> <li> <p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> </li> <li> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> </li> <li> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> </li> <li> <p>Documentar:</p> </li> <li> <p>Tabla con notas, frecuencias y duraci\u00f3n usadas.</p> </li> <li> <p>Evidencia en audio o video de la melod\u00eda funcionando.</p> </li> <li> <p>Recomendaci\u00f3n: La mejor frecuencia de trabajo del buzzer es t\u00edpicamente entre 532 Hz y 4 kHz y adaptar las notas a una octava que suene clara en ese rango.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 2\n#define TOP 2048\n\n// Notas de TU melod\u00eda\n#define FAs 740.0f\n#define RE  587.0f  \n#define SI  494.0f\n#define MI  659.0f\n#define SOLs 831.0f\n#define LA  880.0f\n#define DOs 988.0f\n\n// Duraciones\n#define CORCHEA 214 //duraci\u00f3n de una nota en ms, corchea es nota musical \n#define SILENCIO 214  // Los espacios son silencios de 214ms\n#define SILENCIO_MENOR 50 //Silencio de 50ms\n\nvoid tocar_nota(uint slice, uint chan, float frecuencia, int duracion) {\n    if (frecuencia &gt; 1.0f) {\n        float f_clk = 125000000.0f;\n        float div = f_clk / (frecuencia * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, TOP / 2); //duty al 50%\n        sleep_ms(duracion);\n        pwm_set_chan_level(slice, chan, 0);\n    }\n    sleep_ms(10); // Peque\u00f1a pausa entre notas\n}\n\nvoid tocar_silencio(int duracion) {\n    sleep_ms(duracion);\n} //duraci\u00f3n de silencio\n\nvoid tocar_melodia(uint slice, uint chan) {\n    // FA#FA#RESI\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, RE, CORCHEA);\n    tocar_nota(slice, chan, SI, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // SI\n    tocar_nota(slice, chan, SI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    //MI\n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // MI \n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    // MI SOL# LA DO#\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, SOLs, CORCHEA);\n    tocar_nota(slice, chan, SOLs, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, DOs, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO_MENOR);\n\n    // LALA LAMI\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, RE, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // FA#FA#\n    tocar_nota(slice, chan, FAs, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, FAs, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, TOP / 2);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        tocar_melodia(slice, chan);\n        sleep_ms(2000); // Pausa larga antes de repetir\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#tabla-de-valores","title":"Tabla de valores","text":"<pre><code>| Nota Musical | Duraci\u00f3n| Frecuencia |\n|-------------:|:-------:|:----------:|\n| Fa #         | 214 ms  | 740 Hz     |\n| Re           | 214 ms  | 587 Hz     |\n| Si           | 214 ms  | 494 Hz     |\n| Mi           | 214 ms  | 659 Hz     |\n| Sol#         | 214 ms  | 831 Hz     |\n| La           | 214 ms  | 880 Hz     |\n| Do#          | 214 ms  | 988 Hz     |\n| Silencios    | 214 ms  | -          |\n|Silencio Menor| 214 ms  | -          |\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea7.2/#audio","title":"Audio","text":""},{"location":"Sistemas%20Embebidos/Tarea7.3/","title":"\ud83e\udd16 Tarea 7.3: Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/10/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea7.3/#control-con-frecuencia-buzzer","title":"Control con frecuencia buzzer","text":"<ul> <li> <p>Entregable:</p> </li> <li> <p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> </li> <li> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio:</p> </li> <li> <p>Documentar:</p> </li> <li> <p>Capturas de osciloscopio Antes del filtro (PWM) y Despu\u00e9s del filtro.</p> </li> <li> <p>Explicaci\u00f3n de la frecuencia de corte:</p> </li> <li> <p>El filtro RC se dise\u00f1a para dejar pasar se\u00f1ales de 60 Hz y eliminar las componentes de alta frecuencia que provienen del PWM.</p> </li> <li> <p>La frecuencia de corte (fcf_cfc\u200b) es el punto donde el filtro empieza a atenuar las se\u00f1ales. Matem\u00e1ticamente:</p> </li> </ul> <p>\u200b * En este caso, queremos que fc sea un poco mayor que 60 Hz para que nuestra se\u00f1al sinusoidal de 60 Hz no sea atenuada.</p> <ul> <li> <p>Valores recomendados para un fc\u2248100Hz</p> </li> <li> <p>Opci\u00f3n 1: R=2.2\u2009k\u03a9R C=0.68\u2009\u03bcF fc\u2248106Hz.</p> </li> <li> <p>Opci\u00f3n 2: R=1.6\u2009k\u03a9R, C=1\u2009\u03bcF  fc\u2248100Hz</p> </li> <li> <p>Conexion:</p> </li> <li> <p>La salida de PWM entra en la resistencia.</p> </li> <li> <p>Despu\u00e9s de la resistencia, conectar el capacitor a tierra.</p> </li> <li> <p>El punto entre resistencia y capacitor es la salida filtrada, que se conecta al osciloscopio.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.3/#codigo","title":"C\u00f3digo","text":"<pre><code>// pwm_seno.c \u2014 Generar seno 60 Hz con PWM en GPIO 3\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PIN_PWM    3\n#define FREQ_PWM   2000     // 2 kHz portadora\n#define TOP        1023     // 10 bits de resoluci\u00f3n\n#define FREQ_SENO  60       // Se\u00f1al deseada: 60 Hz\n\n#define PI 3.141592653589793\n\n// N\u00famero de muestras por ciclo de seno\n#define N_MUESTRAS 100\n\nuint16_t tabla_seno[N_MUESTRAS];\n\nint main() {\n    stdio_init_all();\n\n    // --- Generar tabla seno ---\n    for (int i = 0; i &lt; N_MUESTRAS; i++) {\n        float ang = 2 * PI * i / N_MUESTRAS;\n        float val = (sinf(ang) + 1.0f) / 2.0f;  // [0,1]\n        tabla_seno[i] = (uint16_t)(val * TOP);\n    }\n\n    // --- Configuraci\u00f3n PWM ---\n    gpio_set_function(PIN_PWM, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PIN_PWM);\n    uint chan  = pwm_gpio_to_channel(PIN_PWM);\n\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (FREQ_PWM * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n    // --- Temporizaci\u00f3n para 60 Hz ---\n    // Cada ciclo = 16.67 ms. Dividido en N_MUESTRAS \u2192 periodo de actualizaci\u00f3n:\n    float Ts_ms = 1000.0f / (FREQ_SENO * N_MUESTRAS); // ~0.167 ms (167 \u00b5s)\n\n    int idx = 0;\n    while (true) {\n        pwm_set_chan_level(slice, chan, tabla_seno[idx]);\n        idx = (idx + 1) % N_MUESTRAS;\n        sleep_us((int)(Ts_ms * 1000));\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.3/#senal-no-filtrada","title":"Se\u00f1al No Filtrada","text":""},{"location":"Sistemas%20Embebidos/Tarea7.3/#senal-filtrada","title":"Se\u00f1al Filtrada","text":""},{"location":"Sistemas%20Embebidos/Tarea8/","title":"\ud83d\udcda TAREA 8","text":""},{"location":"Sistemas%20Embebidos/Tarea8/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comunicacion uart y usb  </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo  </li> <li>Curso / Asignatura: Sistemas embebidos 1  </li> <li>Fecha: 22/10/25  </li> <li>Descripci\u00f3n breve: _En equipos de 4 conectar dos picos por medio de rx y tx bidireccional para intercambiar mensajes escritos en la consolas de las computadoras. _</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea8/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aprender las utilidades del PWM</li> <li>Espec\u00edficos:</li> <li>Desensamblar y ensamblar strings sin que se corrompan los mensajes_</li> <li>Utilizar frecuencias espec\u00edficas para hacer notas musicales</li> <li>Crear una se\u00f1al sinusoidal a parir de una PWM y un filtro con capacitor y leerla con un osciloscopio</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea8/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>1 capacitor de 1uF, resistencias de 1k y 680 ohms, osciloscopio   -1 buzzer pasivo, 1 resistencia de 220.   -2 botones, resistencias pulldown de 1k, 1 motor DC._</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea8/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/Tarea8/#5-codigos","title":"5) C\u00f3digos","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 17\n#define led_PIN 16\nusing namespace std; //USO DE STRING en la terminal \n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART); // DEFINE TX Y RX\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE); //VELOCIDAD DE TRANSMISI\u00d3N, \n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE); //NO QUEREMOS ENCONTRAR ERRORES DE TRANSMISI\u00d3N, para saber como empieza el msj\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\"; // DEFINE C Y P COMO VARIIABLE DE RECONSTRUCCION, C LA RECIBE LA PALABRA  \n    string p=\"\"; //RECONSTRUYE LA PALABRA QUE VAMOS A ENVIAR\n    while (true){\n\n        int ch = getchar_timeout_us(0); //LEE EL CARACTER\n        if (ch != PICO_ERROR_TIMEOUT) { //SI NO HAY ERROR, ENTONCES IMPRIME EL CARACTER\n            printf(\"Eco: %c\\n\", (char)ch); //IMPRIME EL CARACTER DE LA PALABRA RECIBIDA, \n            p+= (char)ch; //RECONSTRUYE LA PALABRA EN P\n\n            if(ch=='.' || ch=='\\n'){ // CUANDO ENTRA UN PUNTO O UN ENTER \n                uart_puts(UART_ID, p.c_str()); //MANDA LA PALABRA P, AL OTRO PICO, CONVIERTE UN STRING EN UN ARREGLO DE CARACTERES\n                p=\"\"; //VACIAMOS LA PALBRA P, PARA ENVIAR UNA NUEVA\n            }\n        }\n        int a;\n        if (gpio_get(button_pin) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");//HACE QUE FUNCIONE EL BOTON CUANDO SE PRESIONA\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200); \n        }\n         a= gpio_get(button_pin); //TOMA EL VALOR DEL BOTON PIN\n\n        if (uart_is_readable(uart0)) { //SI HAY DATOS PARA LEER\n            char character = uart_getc(uart0); //LEE EL CARACTER\n            printf(character+\"\\n\"); //IMPRIME EL CARACTER RECIBIDO\n\n            if(character=='\\n' || character=='.'){ //CUANDO ENTRA UN PUNTO O UN ENTER\n                if (c == \"LEDON\"){\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n\n                } \n                else if (c == \"Invalid Command\"){\n                    printf(\"Invalid Command\\n\");\n\n                }\n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else{\n                c += character;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea9/","title":"\ud83d\udcda TAREA 9","text":""},{"location":"Sistemas%20Embebidos/Tarea9/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: ADC Luxometro y ADC Servo</li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cortez y Sumie Arai Erazo  </li> <li>Curso / Asignatura: Sistemas embebidos 1  </li> <li>Fecha: 22/10/25 </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea9/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aprender las utilidades del ADC</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea9/#3-codigo-del-luxometro","title":"3) C\u00f3digo del Lux\u00f3metro","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar ADC\n    adc_init();\n\n    // Elegir pin GP26 -&gt; ADC0\n    adc_gpio_init(26);\n    adc_select_input(0);\n\n    while (true) {\n        uint16_t valor_adc = adc_read(); // Valor de 0 a 4095 (12 bits)\n\n        // Calcular porcentaje (0% en 10, 100% en 4095)\n        float porcentaje = 0.0f;\n        if (valor_adc &gt; 10) {\n            porcentaje = ((valor_adc - 10) * 100.0f) / (4095.0f - 10.0f);\n            if (porcentaje &gt; 100.0f)\n                porcentaje = 100.0f; // Limitar por seguridad\n        }\n\n        printf(\"Porcentaje: %.2f%%\\n\", porcentaje);\n        sleep_ms(200);\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea9/#video-luxometro","title":"V\u00eddeo Lux\u00f3metro","text":""},{"location":"Sistemas%20Embebidos/Tarea9/#4-codigo-del-servo","title":"4) C\u00f3digo del Servo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\n#define SERVO_PIN 15\n#define ADC_PIN 26\n\n// Rango total del ADC\n#define ADC_MIN 0\n#define ADC_MAX 4095\n\n// L\u00edmites seguros del servo (en microsegundos)\n#define PULSO_MIN 500.0f\n#define PULSO_MAX 2500.0f\n\n// Promedio para suavizar lectura\n#define NUM_MUESTRAS 1\n\n// === Funci\u00f3n para leer ADC suavizado ===\nuint16_t leer_adc_promedio() {\n    uint32_t suma = 0;\n    for (int i = 0; i &lt; NUM_MUESTRAS; i++) {\n        suma += adc_read();\n        sleep_us(1000);\n    }\n    return (uint16_t)(suma / NUM_MUESTRAS);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar ADC\n    adc_init();\n    adc_gpio_init(ADC_PIN);\n    adc_select_input(0);\n\n    // Configurar PWM para el servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice_num = pwm_gpio_to_slice_num(SERVO_PIN);\n    pwm_set_wrap(slice_num, 24999);      // 50 Hz\n    pwm_set_clkdiv(slice_num, 100.0f);\n    pwm_set_enabled(slice_num, true);\n\n    sleep_ms(500); // estabiliza el ADC\n\n    while (true) {\n        uint16_t valor_adc = leer_adc_promedio();\n\n        // Aseguramos que est\u00e9 dentro del rango v\u00e1lido (0\u20134095)\n        if (valor_adc &gt; 4095) valor_adc = 4095;\n\n        // Calcular porcentaje (0\u20131)\n        float porcentaje = (float)valor_adc / (float)ADC_MAX;\n\n        // Mapear a pulso y \u00e1ngulo\n        float pulso_us = PULSO_MIN + porcentaje * (PULSO_MAX - PULSO_MIN);\n        uint16_t nivel_pwm = (uint16_t)((pulso_us / 20000.0f) * 24999);\n        float angulo = porcentaje * 180.0f;\n\n        // Enviar al servo\n        pwm_set_gpio_level(SERVO_PIN, nivel_pwm);\n\n        // Mostrar datos\n        printf(\"ADC: %u | Pulso: %.1f us | \u00c1ngulo: %.1f\u00b0\\n\",\n               valor_adc, pulso_us, angulo);\n\n        sleep_ms(80);\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea9/#video-del-servo","title":"Video del servo","text":""},{"location":"Sistemas%20Embebidos/Tarea9/#esquematicos","title":"Esquem\u00e1ticos","text":"<p>Nota: El led ser\u00e1 el fotoresistor ya que no existe el componente en wokwi</p>"},{"location":"Sistemas%20Embebidos%202/Actvidad%201/","title":"Session 2 - Class Activity 01","text":""},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#1-exercise-goals","title":"1) Exercise Goals","text":"<p>[x]  Train you to identify logical FreeRTOS tasks from system behavior, even when no RTOS code is shown.</p>"},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#2-materials-setup","title":"2) Materials &amp; Setup","text":"<ul> <li>Tools/Software - Editors: VS Code, Python 3.12</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#3-procedure","title":"3) Procedure","text":""},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#exercise-1","title":"Exercise  1","text":"Task Name Trigger (Time / Event) Periodic or Event-Based Temperature Read Task Time (every 50 ms) Periodic Wi-Fi Send Task Time (every 2 s) Periodic Emergency Button Monitor Event (button press) Event-Based Status LED Blink Task Time (1 Hz / 1 s) Periodic Error Logging Task Event (error detected) Event-Based"},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#exercise-2","title":"Exercise  2","text":"Task Name Time-Critical Can Block Safely If Delayed\u2026 Temperature Read Task Yes, the temperature should be measured at precise intervals to have a correct statistic Yes, it could be blocked, but it will lose the sampling period Sensor data becomes outdated; control decisions may be inaccurate. Wi-Fi Send Task No, the data will arrive at some point Yes, it is not critical communication Data transmission is delayed; buffered data may accumulate. Emergency Button Monitor Yes, immediate action is required No, because blocking may delay the emergency handling Emergency event may not be detected in time, causing safety risk. Status LED Blink Task No, because the logging is not timme  sensitive Yes, it can be surely blocked LED blink becomes irregular; no functional impact. Error Logging Task No, because it is not time sensitive Yes, because it can be deffered Error information may be lost or recorded late."},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#exercise-3","title":"Exercise  3","text":"Task Name Priority (H/M/L) Justification Emergency Button Monitor High Requires immediate response to ensure system and user safety. Temperature Read Task Medium Must meet a fixed sampling period but tolerates small timing jitter. Wi-Fi Send Task Low Communication latency is acceptable and does not affect real-time behavior. Status LED Blink Task Low Purely informative task with no impact on system functionality. Error Logging Task Low Can be deferred without affecting real-time system operation."},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#exercise-4","title":"Exercise  4","text":"<p>Which of the following should NOT necessarily be implemented as a FreeRTOS task?</p> <ul> <li>Emergency button monitoring</li> <li>Wi-Fi transmission</li> <li>Error logging</li> <li>Status LED blinking</li> <li>Explain why in 2\u20133 sentences.</li> </ul> <p>Emergency button, no need to create a task there is no way to scale.</p>"},{"location":"Sistemas%20Embebidos%202/Actvidad%201/#exercise-5-identifying-hidden-tasks-in-pseudo-code","title":"Exercise 5 \u2014 Identifying Hidden Tasks in Pseudo-Code","text":"<p>Task 5.1 \u2014 Identify Hidden Tasks</p> Hidden Task Trigger (Time / Event) Why it should be a Task Temperature Sampling Time (every loop / ~2 ms) Requires periodic measurements for it to have he correct statistics. Emergency Button Monitoring Event (button press) Safety-critical and requires immediate response. Wi-Fi Data Transmission Time (every 2 seconds) The system will be fully resposive Status LED Blinking Time (1 Hz) Periodic behavior independent of main control flow. <p>Task 5.2 \u2014 Blocking Analysis</p> <ul> <li> <p>The function send_data_over_wifi() can block the CPU for 100\u2013300 ms.</p> </li> <li> <p>While it blocks, button monitoring, temperature sampling, and LED timing are delayed.</p> </li> <li> <p>The emergency button monitoring task is most at risk because delayed response can cause a safety failure.</p> </li> </ul> <p>Task 5.3 \u2014 RTOS Refactoring Thought Experiment - Temperature sampling and Wi-Fi transmission because the temperature sensor requires a periodic timing for it to operates properly and the wi-fi transmission is blocking other tasks to execute and is slower. - Emergency button handling should be triggered by an interrupt to guarantee immediate response. - The emergency button task should have the highest priority because it is safety-critical.</p>"},{"location":"Sistemas%20Embebidos%202/Lab01/","title":"Session 3 - Lab Homework","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#1-exercise-goals","title":"1) Exercise Goals","text":"<p>[x]  Read and answer the questions from Labs 1 trough 3</p>"},{"location":"Sistemas%20Embebidos%202/Lab01/#2-materials-setup","title":"2) Materials &amp; Setup","text":"<ul> <li>Tools/Software - Editors: VS Code, Python 3.12</li> <li>Hardware - ESP32-C6, LED</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#3-procedure","title":"3) Procedure","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#lab-1","title":"Lab 1","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#first-code","title":"First Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working-without-modifications","title":"Video of it working without modifications","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#experiment-1","title":"Experiment 1","text":"<ul> <li>Priority experiment: change hello_task priority from 5 to 2.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#new-code","title":"New Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 2, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working","title":"Video of it working","text":"<ul> <li>Does behavior change? Why might it (or might it not)? - There is no noticeable change, due to the VTaskDelay() function, which makes that must of the time the tasks are in a Blocked state, and spend 99% of their time sleeping, so the low priority task could do it without a noticeable delay, it will matters if both tasks are ready to run at the same microsecond.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#experiment-2","title":"Experiment  2","text":"<ul> <li>Starvation demo: temporarily remove vTaskDelay(...) from hello_task.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#new-code_1","title":"New Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_2   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    // Stack size in ESP-IDF FreeRTOS is in BYTES\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 2, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working_1","title":"Video of it working","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working-with-hello_task-as-a-higher-priority","title":"Video of it working with hello_task as a higher priority","text":"<ul> <li> <p>What happens to blinking? - The LED is still blinking, even if the priority is lower or the same as the hello_task, however, the however_task will run without delays in the moniitor, which in some cases will crash. In addition, if we change the priority of the hello_task to a higher one, the led will blink faster, making it loooks like it is completly on, because it is stuck in the Ready progress, it is showed in the second video.</p> </li> <li> <p>Put the delay back and explain in one sentence why blocking helps. - It helps, to move tasks to a blocked state and let other tasks to run until its time has passed.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#lab-2-queue-producerconsumer","title":"Lab 2 Queue: producer/consumer","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#first-code_1","title":"First Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working-without-modifications_1","title":"Video of it working without modifications","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#experiment-1_1","title":"Experiment 1","text":"<ul> <li>Make the producer faster: change producer delay 200ms \u2192 20ms.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#new-code_2","title":"New Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(20));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working_2","title":"Video of it working","text":"<ul> <li>When do you see \u201cQueue full\u201d? - I never see the queue full, since my consumer is faster than the consumer,because, it is awake like all the time, since the producer is sending information every 20 ms. But i should see it when the producer is putting items into the queue faster than the consumer can take them out.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#experiment-2_1","title":"Experiment 2","text":"<ul> <li>Increase the queue length 5 \u2192 20.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#line-of-code-changed","title":"Line of code changed","text":"<pre><code>q_numbers = xQueueCreate(20, sizeof(int)); // length 5\n</code></pre>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-modified","title":"Video of it modified","text":"<ul> <li>What changed - In my case there is no noticeable difference, because the consumer is faster than the consumer, because it has no delay and is awake every time the producer is sending data, so, is always ready to recieve the new message, making the queue always empty for new data.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#experiment-3","title":"Experiment 3","text":"<ul> <li>Make the consumer \u201cslow\u201d: after a successful receive, add: vTaskDelay(pdMS_TO_TICKS(300));</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working_3","title":"Video of it working","text":"<ul> <li>What pattern is happening now (buffering / backlog)? - Both of them, since, for backlog my producer is faster than the consumer making a backlog of 20 numbers waiting to be processed, making also an overflow which is loosing data, the queue is full, due to the producer which is faster, so in some point it starts buffering.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#lab-3-mutex-protect-a-shared-resource","title":"Lab 3 Mutex: protect a shared resource","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#first-code-race-demo-no-mutex","title":"First Code Race Demo no mutex","text":"<p><pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre> - Why can the counter be wrong? - Because, the task is divided in 3 instructions, one thhat reads, the other that adds and the last one that returns the value, and if any of the instructions is interrupted, it will loose an increment. </p>"},{"location":"Sistemas%20Embebidos%202/Lab01/#first-code-fix-with-a-mutex","title":"First code fix with a mutex","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3B\";\n\nstatic volatile int shared_counter = 0;\nstatic SemaphoreHandle_t counter_mutex;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        xSemaphoreGive(counter_mutex);\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3B (mutex fix)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    if (counter_mutex == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working-wo-modifications","title":"Video of it working w/o modifications","text":"<ul> <li>Remove the mutex again. Do you ever see weird behavior? - I don\u00b4t see a weird behaviour, compared to the other one.</li> </ul>"},{"location":"Sistemas%20Embebidos%202/Lab01/#video-of-it-working_4","title":"Video of it working","text":""},{"location":"Sistemas%20Embebidos%202/Lab01/#change-priorities-taska-priority-6-taskb-priority-4","title":"Change priorities: TaskA priority 6, TaskB priority 4.","text":"<ul> <li> <p>What do you expect and why - I expect that task A dominates the execution, and for it I could barely see task B</p> </li> <li> <p>In one sentence: what does a mutex \u201cguarantee\u201d? - It guarantees that only one task at a time can access a shared resource.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/","title":"Session 3 - Task Excercise","text":"<ul> <li>Understand the use of the mutex</li> </ul>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/#1-activity-goal","title":"1) Activity Goal","text":"<p>[x]  Create the 7 task code</p> <p>[X] Task 1 Heartbeat [X] Task 2 Alive task [X] Task 3 Queue Struct Send [X] Task 4 Queue Struct Receive [X] Task 5 and 6 Mutex reading a button [X] Task 7 Error loggin for task 1-6</p>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/#2-materials-setup","title":"2) Materials &amp; Setup","text":"<ul> <li>Tools/Software - Editors: VS Code, Python 3.12, ESP32-IDF</li> </ul> <p>Wiring/Safety: ESP32-IDF, LED, BUTTON, RESISTANCE OF 1KOHM AND 220 OHMS</p>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/#3-procedure","title":"3) Procedure","text":"<p>We start task by task, analyzing, how to adapt it to the previous one.</p>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/#4-data-tests-evidence","title":"4) Data, Tests &amp; Evidence","text":"<p>We understand from the evidence obtained that in some cases we have to change the priority of tasks for it to work properly, and the mutex part, could execute both tasks.</p>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/#5-analysis","title":"5) Analysis","text":"<p>Is necessary to asssign the priorities of the tasks in order for it to work properly, and to have a better organization of the tasks</p>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/#6-code","title":"6) Code","text":"<p>The final code done is the following one: <pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO    GPIO_NUM_2\n#define BUTTON_GPIO GPIO_NUM_19  \n\nstatic const char *TAG = \"HOMEWORK\";\n\ntypedef struct {\n    int id;\n    int value;\n} data_t;\n\nstatic QueueHandle_t data_queue = NULL;\nstatic SemaphoreHandle_t btn_mutex = NULL;\n\n// Arreglo para la Task 7 \nstatic uint32_t task_counters[6] = {0};\n\n\nstatic void heartbeat_task(void *pvParameters) {\n    while (1) {\n        task_counters[0]++; // Avisa que est\u00e1 viva\n        gpio_set_level(LED_GPIO, 1); \n        vTaskDelay(pdMS_TO_TICKS(400)); \n        gpio_set_level(LED_GPIO, 0); \n        vTaskDelay(pdMS_TO_TICKS(300)); \n        gpio_set_level(LED_GPIO, 1); \n        vTaskDelay(pdMS_TO_TICKS(300)); \n        gpio_set_level(LED_GPIO, 0); \n        vTaskDelay(pdMS_TO_TICKS(250));\n    }\n}\n\nstatic void alive_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        task_counters[1]++;\n        ESP_LOGI(TAG, \"Alive: n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void queue_send_task(void *pvParameters) {\n    data_t msg;\n\n    int counter = 0;\n    while (1) {\n\n        task_counters[2]++;\n        msg.id = 3;\n        msg.value = counter++;\n\n        if (xQueueSend(data_queue, &amp;msg, pdMS_TO_TICKS(100)) == pdPASS) {\n            ESP_LOGI(\"QUEUE_SEND\", \"Enviado a cola: ID=%d, Val=%d\", msg.id, msg.value);\n        }\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\n\nstatic void queue_receive_task(void *pvParameters) {\n    data_t received_msg;\n    while (1) {\n        task_counters[3]++;\n        if (xQueueReceive(data_queue, &amp;received_msg, portMAX_DELAY) == pdPASS) {\n            ESP_LOGI(\"QUEUE_RECV\", \"Recibido de cola: ID=%d, Val=%d\", \n                     received_msg.id, received_msg.value);\n        }\n    }\n}\n\n\nstatic void mutex_button_task(void *pvParameters) {\n    int task_id = (int)pvParameters; \n    const char* name = (task_id == 4) ? \"Tarea 5\" : \"Tarea 6\";\n\n    while (1) {\n        task_counters[task_id]++;\n\n\n        if (xSemaphoreTake(btn_mutex, portMAX_DELAY) == pdTRUE) {\n            int level = gpio_get_level(BUTTON_GPIO);\n            ESP_LOGI(\"MUTEX_READ\", \"[%s] Ley\u00f3 bot\u00f3n: %s\", name, level ? \"Presionado\" : \"Suelto\");\n\n\n            vTaskDelay(pdMS_TO_TICKS(150)); \n\n            xSemaphoreGive(btn_mutex); \n        }\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\n\nstatic void monitor_task(void *pvParameters) {\n    uint32_t last_counters[6] = {0};\n\n    while (1) {\n        vTaskDelay(pdMS_TO_TICKS(5000)); \n        ESP_LOGI(\"MONITOR\", \"Verficicando tareas\");\n\n        for (int i = 0; i &lt; 6; i++) {\n            if (task_counters[i] == last_counters[i]) {\n                ESP_LOGI(\"MONITOR\", \"ERROR: Tarea %d detenida\", i + 1);\n            } else {\n                last_counters[i] = task_counters[i];\n            }\n        }\n    }\n}\n\n\nvoid app_main(void) {\n\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_pullup_en(BUTTON_GPIO);\n\n\n    data_queue = xQueueCreate(5, sizeof(data_t));\n    btn_mutex = xSemaphoreCreateMutex();\n\n    if (data_queue != NULL &amp;&amp; btn_mutex != NULL) {\n\n        xTaskCreate(heartbeat_task,     \"T1\",  2048, NULL,   1, NULL);\n        xTaskCreate(alive_task,         \"T2\",  2048, NULL,   1, NULL);\n        xTaskCreate(queue_send_task,    \"T3\",   2048, NULL,   2, NULL);\n        xTaskCreate(queue_receive_task, \"T4\",   2048, NULL,   2, NULL);\n\n\n        xTaskCreate(mutex_button_task,  \"T5\",    2048, (void*)4, 3, NULL);\n        xTaskCreate(mutex_button_task,  \"T6\",    2048, (void*)5, 3, NULL);\n\n        xTaskCreate(monitor_task,       \"T7\",    2048, NULL,   5, NULL);\n\n    }\n}\n</code></pre></p>"},{"location":"Sistemas%20Embebidos%202/TaskExcercise/#7-files-and-media","title":"7 files and media","text":"<ul> <li>This is the video of it working.</li> </ul>"}]}