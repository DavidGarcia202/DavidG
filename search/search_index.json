{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"David Garc\u00eda","text":"<p>Hola! \ud83d\udc4b Esta es la p\u00e1gina web de David Garc\u00eda destinada para reportar tareas y proyectos de las materias Proyectos 4 y Sistemas Embebidos.</p>"},{"location":"Ejemplos/comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"Ejemplos/comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"Ejemplos/comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"Ejemplos/comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"Ejemplos/comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"Ejemplos/comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"Ejemplos/comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"Ejemplos/comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"Ejemplos/comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"Ejemplos/comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"Ejemplos/comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Ejemplos/comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"Ejemplos/comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"Ejemplos/comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"Ejemplos/comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"Ejemplos/comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"Ejemplos/ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Ejemplos/ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Ejemplos/ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Ejemplos/ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Ejemplos/ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Ejemplos/ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Ejemplos/gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"Ejemplos/gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"Ejemplos/gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"Ejemplos/gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"Ejemplos/gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"Ejemplos/gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"Ejemplos/gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"Ejemplos/gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Proyectos4/1_Perfil/","title":"\ud83d\udcbfPerfil","text":""},{"location":"Proyectos4/1_Perfil/#soy-juan-david-garcia-cortez-estoy-en-quinto-semestre-de-ingenieria-mecatronica-en-este-momento-de-mi-vida-me-gustaria-trabajar-en-el-desarrollo-de-instalaciones-interactivas-o-en-robots-de-ensamble","title":"Soy Juan David Garc\u00eda Cortez, estoy en quinto semestre de Ingenier\u00eda Mecatr\u00f3nica, en este momento de mi vida me gustar\u00eda trabajar en el desarrollo de instalaciones interactivas o en robots de ensamble.","text":""},{"location":"Proyectos4/Costos/","title":"Costos","text":"<p>Costos de David Garc\u00eda</p>"},{"location":"Proyectos4/Gannt/","title":"Diagrama de Gannt","text":""},{"location":"Proyectos4/Proyecto/","title":"Nuestro Proyecto","text":"<p>Proyecto de Sumie Arai, David Garcia y Rodrigo Miranda </p>"},{"location":"Proyectos4/Semana2/","title":"Semana 2","text":""},{"location":"Proyectos4/Semana2/#capsulas-de-cafe","title":"C\u00e1psulas de Caf\u00e9","text":"<p>C\u00e1psulas de Caf\u00e9 de Sumie Arai, David Garc\u00eda</p>"},{"location":"Proyectos4/Semana2/#nuestro-proyecto","title":"Nuestro Proyecto","text":"<p>Presentaci\u00f3n extra</p>"},{"location":"Proyectos4/Semana4/","title":"Semana 4","text":""},{"location":"Proyectos4/Semana4/#por-que-mi-proyecto-es-importante","title":"\u00bfPor qu\u00e9 mi proyecto es importante?","text":"<p>Estacionamiento Inteligente de Sumie Arai</p>"},{"location":"Proyectos4/Semana5/","title":"Segmentaci\u00f3n","text":"<p>Tabla de Valor de David Garc\u00eda, Sumie Arai y Rodrigo Miranda</p> <p>Segmentaci\u00f3n de David Garc\u00eda, Sumie Arai y Rodrigo Miranda</p>"},{"location":"Proyectos4/Syllabus/","title":"Syllabus Firmado","text":""},{"location":"Sistemas%20Embebidos/EXAMEN2/","title":"\ud83d\udcda Examen 2do Parcial","text":""},{"location":"Sistemas%20Embebidos/EXAMEN2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo  </li> <li>Curso / Asignatura: Sistemas embebidos 1  </li> <li>Fecha: 23/10/25  </li> <li>Descripci\u00f3n breve: _Examen 2do Parcial. _</li> </ul>"},{"location":"Sistemas%20Embebidos/EXAMEN2/#2-instrucciones","title":"2) Instrucciones","text":"<ul> <li>Hardware m\u00ednimo: 1 \u00d7 servomotor en un pin PWM (50 Hz).<ul> <li>Hardware m\u00ednimo: 3 \u00d7 botones: BTN_MODE (cambia modo), BTN_NEXT (siguiente), BTN_PREV (anterior).</li> <li>Usar Raspberry Pi Pico como controlador.</li> <li>Modo Entrenamiento: recibir comandos por USB-serial (borrar/clear, escribir/write, reemplazar/replace) y responder OK o errores seg\u00fan validez de argumentos.</li> <li>Modo Continuo: recorrer todas las posiciones de la lista en orden y mostrar cada 1.5 s el texto \"posX: V\"; si la lista est\u00e1 vac\u00eda, imprimir \"Error no hay pos\" cada 1.5 s y no mover el servo.</li> <li>Modo Step: BTN_NEXT avanza una posici\u00f3n (no pasa de la \u00faltima); BTN_PREV retrocede (no baja de la primera); en cada cambio imprimir \"posX: V\" y mover el servo; si la lista est\u00e1 vac\u00eda, al presionar los botones imprimir \"Error no hay pos\" y no mover el servo.</li> <li>Comandos seriales (aceptar may\u00fasculas/min\u00fasculas y aliases en ingl\u00e9s):<ul> <li>Borrar / clear: sintaxis \"Borrar\" \u2014 elimina la lista completa de posiciones \u2014 respuesta: OK.</li> <li>Escribir / write: sintaxis \"Escribir, v1, v2, ..., vn\" con valores 0\u2013180 \u2014 sobrescribe la lista \u2014 respuesta: OK si v\u00e1lidos; si alguno inv\u00e1lido o lista vac\u00eda \u2192 \"Error argumento invalido\".</li> <li>Reemplazar / replace: sintaxis \"Reemplazar, i, v\" con i base 1 y v en 0\u2013180 \u2014 reemplaza posici\u00f3n i por v \u2014 respuesta: OK; si i no existe \u2192 \"Error indice invalido\"; si v fuera de rango \u2192 \"Error argumento invalido\".</li> </ul> </li> <li>Formato de salida serial en modos: imprimir \"posX: V\" donde X es \u00edndice base 1 y V el \u00e1ngulo.</li> <li>Nota de conexi\u00f3n y PWM: el movimiento del servo requiere alimentaci\u00f3n 5\u20136 V; la se\u00f1al de control se conecta al pin de se\u00f1al del servo; la frecuencia PWM debe ser 50 Hz y el pulso de control entre 1 ms (0\u00b0) y 2 ms (180\u00b0).</li> </ul> </li> </ul>"},{"location":"Sistemas%20Embebidos/EXAMEN2/#3-materiales","title":"3) Materiales","text":"<ul> <li>Incluye:    -1 servomotor.   -3 botones, resistencias pulldown de 1k, 1 motor DC._</li> </ul>"},{"location":"Sistemas%20Embebidos/EXAMEN2/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;                          // include de C: funciones de entrada/salida (printf, getchar, etc.)\n#include \"pico/stdlib.h\"                    // SDK de la Raspberry Pi Pico: sleep_ms, stdio_init_all, make_timeout_time_ms, funciones de tiempo y stdio USB\n#include \"hardware/pwm.h\"                  // API hardware para PWM en la Pico (pwm_set_chan_level, pwm_set_wrap, pwm_set_clkdiv, etc.)\n#include \"hardware/gpio.h\"                 // API hardware para GPIO (gpio_init, gpio_set_dir, gpio_pull_up, gpio_set_irq_enabled, gpio_get, etc.)\n#include &lt;string&gt;                           // std::string (clase C++ para manejo de cadenas)\n#include &lt;vector&gt;                           // std::vector (contenedor din\u00e1mico C++)\n#include &lt;cctype&gt;                           // funciones para caracteres: isdigit, tolower, etc.\n\n#define SERVO_PIN 15                       // Macro: nombre simb\u00f3lico para pin del servo (GPIO 15). Reemplazo por el preprocesador.\n#define BTN_MODE 2                         // Pin del bot\u00f3n que cambia el modo (GPIO 2)\n#define BTN_NEXT 3                         // Pin del bot\u00f3n \"siguiente\" (GPIO 3)\n#define BTN_PREV 4                         // Pin del bot\u00f3n \"anterior\" (GPIO 4)\n\nusing namespace std;                       // Evita escribir std:: antes de string, vector, etc. (\u00fatil pero puede contaminar el namespace)\n\n\n// --- Variables globales ---\nvector&lt;int&gt; posiciones;                    // Vector din\u00e1mico de enteros: lista de \u00e1ngulos (0-180) que el servo debe usar.\nint indice_actual = 0;                     // \u00cdndice actual dentro de 'posiciones' (base 0)\nvolatile int modo_actual = 1;              // Variable compartida con la ISR: modo actual (1=Entrenamiento,2=Continuo,3=Step)\nvolatile bool ciclo_activo = false;        // Bandera compartida: si el ciclo del modo continuo est\u00e1 activo o no\n                                          // 'volatile' evita optimizaciones que asumir\u00edan que la variable no cambia fuera del flujo principal.\n\n\n// --- Funciones auxiliares ---\nbool es_numero(const string&amp; str) {        // Funci\u00f3n: devuelve true si 'str' contiene solo d\u00edgitos o un '-' al inicio (permite negativos)\n    if (str.empty()) return false;         // Si cadena vac\u00eda -&gt; no es n\u00famero\n    for (char c : str) {                   // Recorre cada car\u00e1cter de la cadena\n        if (!isdigit(c) &amp;&amp; c != '-') return false; // isdigit() viene de &lt;cctype&gt;; si no es d\u00edgito ni '-', no es n\u00famero v\u00e1lido\n    }\n    return true;                           // Si todos los caracteres pasaron la prueba, es n\u00famero (o probable n\u00famero con signo)\n}\n\nint string_a_int(const string&amp; str) {      // Convierte cadena decimal a int SIN usar stoi (control manual de errores)\n    int resultado = 0;                     // Acumulador del n\u00famero\n    int signo = 1;                         // Factor de signo (1 o -1)\n    size_t inicio = 0;                     // Posici\u00f3n de inicio para lectura (si hay '-', empezamos en 1)\n    if (str[0] == '-') {                   // Si el primer car\u00e1cter es '-', manejamos negativo\n        signo = -1;\n        inicio = 1;\n    }\n    for (size_t i = inicio; i &lt; str.length(); i++) { // Recorre desde 'inicio' hasta el final\n        if (isdigit(str[i])) {             // Si el car\u00e1cter es d\u00edgito\n            resultado = resultado * 10 + (str[i] - '0'); // Convierte car\u00e1cter a n\u00famero: '3' -&gt; 3 sum\u00e1ndolo en base 10\n        } else {\n            return -9999;                  // C\u00f3digo de error: se encontr\u00f3 car\u00e1cter inv\u00e1lido (evita excepciones)\n        }\n    }\n    return resultado * signo;              // Devuelve el valor con signo\n}\n\nvoid mostrar_bienvenida() {                // Imprime por serial el men\u00fa y comandos disponibles\n    printf(\"\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"    SISTEMA DE CONTROL DE SERVO\\n\");\n    printf(\"         Raspberry Pi Pico\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"Modos disponibles:\\n\");\n    printf(\"  1 - Entrenamiento\\n\");\n    printf(\"  2 - Continuo\\n\");\n    printf(\"  3 - Step\\n\");\n    printf(\"\\n\");\n    printf(\"Comandos disponibles:\\n\");\n    printf(\"  escribir, write - Guardar posiciones\\n\");\n    printf(\"  borrar, clear   - Borrar lista\\n\");\n    printf(\"  reemplazar, replace - Modificar posicion\\n\");\n    printf(\"  help, ayuda     - Mostrar este mensaje\\n\");\n    printf(\"\\n\");\n    printf(\"Presiona BTN_MODE para cambiar modos\\n\");\n    printf(\"=========================================\\n\");\n    printf(\"\\n\");\n}\n\nvoid borrar_lista() {                      // Borra el vector de posiciones y reinicia el \u00edndice\n    posiciones.clear();                    // .clear() borra todos los elementos del vector (tama\u00f1o=0)\n    indice_actual = 0;                     // Reinicia \u00edndice\n    printf(\"OK\\n\");                        // Confirma la operaci\u00f3n por serial\n}\n\nuint16_t angle_to_level(uint16_t angle) {  // Convierte \u00e1ngulo (0-180) a nivel PWM (0-65535)\n    // Para servo est\u00e1ndar: 0\u00b0 = 1000us, 180\u00b0 = 2000us\n    float min_pulse_us = 1000.0f;          // Pulso m\u00ednimo en microsegundos (1 ms) equivalente a 0\u00b0\n    float max_pulse_us = 2000.0f;          // Pulso m\u00e1ximo en microsegundos (2 ms) equivalente a 180\u00b0\n    float period_us = 20000.0f;            // Periodo total en microsegundos: 20 ms = 1 / 50 Hz (50 Hz t\u00edpico de servos)\n\n    // Calcular pulso para el \u00e1ngulo (interpolaci\u00f3n lineal)\n    float pulse_us = min_pulse_us + (angle * (max_pulse_us - min_pulse_us) / 180.0f);\n    // Explicaci\u00f3n: (max - min) es la amplitud del pulso; se escala por angle/180 para mapear 0..180 a 0..(max-min).\n\n    // Convertir a nivel PWM de 16 bits:\n    // PWM level = (pulse_us / period_us) * 65535\n    // 65535 es el valor m\u00e1ximo del contador cuando wrap=65535 (resoluci\u00f3n 16-bit).\n    return (uint16_t)((pulse_us / period_us) * 65535.0f);\n}\n\nvoid mover_servo(uint slice, uint chan, int ang) { // Env\u00eda el valor PWM correspondiente al \u00e1ngulo\n    if (ang &lt; 0) ang = 0;                  // Clampa \u00e1ngulo m\u00ednimo\n    if (ang &gt; 180) ang = 180;              // Clampa \u00e1ngulo m\u00e1ximo\n    pwm_set_chan_level(slice, chan, angle_to_level(ang)); // Llama al SDK: fija el nivel del canal PWM\n    // pwm_set_chan_level(slice,chan,level) escribe el valor (0..wrap) que se mantiene activo en cada ciclo PWM.\n}\n\n// Interrupci\u00f3n para cambiar modo\nvoid gpio_callback(uint gpio, uint32_t events) { // Funci\u00f3n llamada por la IRQ del GPIO (callback)\n    if (gpio == BTN_MODE) {                  // Si la interrupci\u00f3n vino del pin BTN_MODE\n        modo_actual++;                       // Incrementa modo c\u00edclicamente\n        if (modo_actual &gt; 3) modo_actual = 1;// Vuelve a 1 despu\u00e9s de 3 (1-&gt;2-&gt;3-&gt;1)\n        ciclo_activo = (modo_actual == 2);   // Si modo==2 (Continuo), activa el ciclo; si no, lo desactiva\n\n        printf(\"\\n=== Modo cambiado ===\\n\");  // Mensaje de cambio de modo\n        switch(modo_actual) {                // Muestra texto seg\u00fan el modo\n            case 1: printf(\"MODO ENTRENAMIENTO activado\\n\"); break;\n            case 2: printf(\"MODO CONTINUO activado\\n\"); break;\n            case 3: printf(\"MODO STEP activado\\n\"); break;\n        }\n        printf(\"=====================\\n\");\n\n        if (!posiciones.empty()) {           // Si hay posiciones cargadas, reinicia el \u00edndice a 0\n            indice_actual = 0;\n        }\n    }\n}\n\n// Procesar comando de consola\nvoid procesar_comando(const string&amp; cmd, uint slice, uint chan) { // Recibe el comando como string y los ids PWM slice/chan\n    string cmd_lower = cmd;                 // Copia del comando\n    for (char &amp;c : cmd_lower) c = tolower(c); // Convierte todos los caracteres a min\u00fasculas para comparar sin case-sensitivity\n\n    if (cmd_lower == \"write\" || cmd_lower == \"escribir\") { // Comando para escribir posiciones\n        printf(\"Ingresa valores separados por comas (ej: 0,90,130): \");\n        string entrada = \"\";\n\n        absolute_time_t timeout = make_timeout_time_ms(10000); // Crea un timeout de 10 s (evita bloqueo indefinido)\n        while (true) {                       // Bucle para leer caracteres desde stdio (USB serial)\n            int c = getchar_timeout_us(100000); // Lee con timeout en microsegundos (100000us = 100ms)\n            if (c != PICO_ERROR_TIMEOUT) {   // Si hay dato disponible\n                if (c == '\\n' || c == '\\r') break; // Enter -&gt; fin de entrada\n                entrada += (char)c;         // Agrega car\u00e1cter a la cadena\n                printf(\"%c\", c);            // Eco del car\u00e1cter (para ver lo que se escribe)\n            }\n            if (time_reached(timeout)) {    // Si el tiempo de entrada expir\u00f3\n                printf(\"\\nError: timeout en entrada\\n\");\n                return;                     // Sale sin procesar (evita bloquear)\n            }\n        }\n        printf(\"\\n\");\n\n        if (entrada.empty()) {              // Si no se ingres\u00f3 nada\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        vector&lt;int&gt; temp_pos;               // Vector temporal donde guardaremos los valores parseados\n        string temp = \"\";\n\n        for (char c : entrada) {            // Parseo manual de la lista separada por comas\n            if (c == ',') {                 // Si encontramos separador\n                if (!temp.empty()) {\n                    if (!es_numero(temp)) { // Validaci\u00f3n: temp debe ser num\u00e9rico\n                        printf(\"Error argumento invalido\\n\");\n                        return;\n                    }\n                    int val = string_a_int(temp); // Conversi\u00f3n segura a int\n                    if (val &lt; 0 || val &gt; 180) {   // Validaci\u00f3n de rango de \u00e1ngulo\n                        printf(\"Error argumento invalido\\n\");\n                        return;\n                    }\n                    temp_pos.push_back(val);  // A\u00f1ade al vector temporal\n                    temp = \"\";                // Resetea temp para el siguiente n\u00famero\n                }\n            } else if (c != ' ') {          // Ignora espacios\n                temp += c;                  // Acumula car\u00e1cter\n            }\n        }\n        if (!temp.empty()) {                // Si qued\u00f3 un \u00faltimo n\u00famero tras el \u00faltimo separador\n            if (!es_numero(temp)) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            int val = string_a_int(temp);\n            if (val &lt; 0 || val &gt; 180) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            temp_pos.push_back(val);\n        }\n\n        if (temp_pos.empty()) {             // Si no se logr\u00f3 parsear nada v\u00e1lido\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        posiciones = temp_pos;              // Asigna el vector parseado a la variable global\n        indice_actual = 0;                  // Reinicia \u00edndice\n        printf(\"OK - %d posiciones guardadas: \", (int)posiciones.size());\n        for (size_t i = 0; i &lt; posiciones.size(); i++) { // Muestra las posiciones guardadas\n            printf(\"%d\", posiciones[i]);\n            if (i &lt; posiciones.size() - 1) printf(\", \");\n        }\n        printf(\"\\n\");\n\n    } else if (cmd_lower == \"clear\" || cmd_lower == \"borrar\") { // Comando borrar lista\n        borrar_lista();\n\n    } else if (cmd_lower == \"replace\" || cmd_lower == \"reemplazar\") { // Reemplazar una posici\u00f3n dada\n        printf(\"Ingresa posicion,valor (ej: 1,130): \");\n        string entrada = \"\";\n        absolute_time_t timeout = make_timeout_time_ms(10000);\n        while (true) {\n            int c = getchar_timeout_us(100000);\n            if (c != PICO_ERROR_TIMEOUT) {\n                if (c == '\\n' || c == '\\r') break;\n                entrada += (char)c;\n                printf(\"%c\", c);\n            }\n            if (time_reached(timeout)) {\n                printf(\"\\nError: timeout en entrada\\n\");\n                return;\n            }\n        }\n        printf(\"\\n\");\n        if (entrada.empty()) {\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        int pos = -1, val = -1;             // Inicializa variables para \u00edndice (pos) y valor (val)\n        string temp = \"\";\n        bool sep = false;                   // Indica si ya le\u00edmos la coma separadora\n        for (char c : entrada) {\n            if (c == ',' &amp;&amp; !sep) {         // En la primera coma separamos posici\u00f3n y valor\n                if (!es_numero(temp)) {\n                    printf(\"Error argumento invalido\\n\");\n                    return;\n                }\n                pos = string_a_int(temp) - 1; // La interfaz pide posiciones 1-based, internamente se usa 0-based =&gt; restamos 1\n                if (pos == -10000) {        // Verifica c\u00f3digos de error (aunque string_a_int devuelve -9999, es chequeo defensivo)\n                    printf(\"Error argumento invalido\\n\");\n                    return;\n                }\n                temp = \"\";\n                sep = true;\n            } else if (c != ' ') {\n                temp += c;                  // Acumula el valor despu\u00e9s de la coma\n            }\n        }\n        if (sep &amp;&amp; !temp.empty()) {         // Si hubo coma y qued\u00f3 valor para leer\n            if (!es_numero(temp)) {\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n            val = string_a_int(temp);\n            if (val == -9999) {            // C\u00f3digo de error desde string_a_int\n                printf(\"Error argumento invalido\\n\");\n                return;\n            }\n        }\n\n        if (pos &lt; 0 || pos &gt;= (int)posiciones.size()) { // Validaci\u00f3n del \u00edndice dentro del vector\n            printf(\"Error indice invalido\\n\");\n        } else if (val &lt; 0 || val &gt; 180) {  // Validaci\u00f3n del nuevo valor\n            printf(\"Error argumento invalido\\n\");\n        } else {\n            posiciones[pos] = val;          // Reemplaza la posici\u00f3n solicitada\n            printf(\"OK - Posicion %d actualizada a %d grados\\n\", pos + 1, val); // Muestra confirmaci\u00f3n (pos+1 para usuario)\n        }\n\n    } else if (cmd_lower == \"help\" || cmd_lower == \"ayuda\" || cmd_lower == \"?\") { // Comando ayuda\n        mostrar_bienvenida();\n\n    } else {                               // Comando no reconocido\n        printf(\"Comando no reconocido: '%s'\\n\", cmd.c_str());\n        printf(\"Escribe 'help' para ver comandos disponibles\\n\");\n    }\n}\n\n// --- Programa principal ---\nint main() {\n    // Inicializar USB serial\n    stdio_init_all();                      // Inicializa stdio (incluye USB-Serial si est\u00e1 habilitado en la build)\n\n    // Esperar a que se conecte el monitor serial\n    sleep_ms(3000);                        // Pausa 3000 ms para dar tiempo al host a abrir el puerto serie\n\n    // Mostrar mensaje de bienvenida\n    mostrar_bienvenida();\n    printf(\"Sistema inicializado. Esperando comandos...\\n\");\n    printf(\"&gt; \");                          // Prompt para el usuario\n\n    // Configurar PWM para servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM); // Asigna la funci\u00f3n PWM al pin f\u00edsico SERVO_PIN (GPIO 15)\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN); // Obtiene el n\u00famero de \"slice\" PWM asociado a ese pin\n    uint chan = pwm_gpio_to_channel(SERVO_PIN); // Obtiene el canal (A/B) dentro del slice para ese pin\n    pwm_set_wrap(slice, 65535);            // 'wrap' define el valor m\u00e1ximo del contador PWM (aqu\u00ed 65535 \u2192 16 bits)\n\n    // Configurar el divisor para 50Hz\n    // Explicaci\u00f3n matem\u00e1tica:\n    // PWM_freq = sys_clock_hz / (clkdiv * (wrap + 1))\n    // =&gt; clkdiv = sys_clock_hz / (PWM_freq * (wrap + 1))\n    // En la Pico t\u00edpicamente sys_clock_hz = 125000000 (125 MHz)\n    // Con wrap = 65535 (=&gt; wrap+1 = 65536) y PWM_freq = 50 Hz:\n    // clkdiv \u2248 125e6 / (50 * 65536) \u2248 38.146...\n    // El autor escribi\u00f3 la f\u00f3rmula manipulando unidades para obtener el mismo resultado:\n    float div = 125.0f / (50.0f * 65535.0f / 1000000.0f);\n    // - 125.0f representa 125 MHz (la frecuencia base en MHz)\n    // - 65535.0f / 1000000.0f convierte el 'wrap' a \"mega-unidades\" para que las unidades cuadren.\n    // Resultado: div \u2248 38.15 -&gt; valor de clkdiv que produce ~50 Hz.\n    pwm_set_clkdiv(slice, div);            // Ajusta el divisor del reloj PWM (acepta float)\n    pwm_set_enabled(slice, true);          // Habilita el slice PWM\n\n    // Configurar botones (modo: entrada con pull-up)\n    gpio_init(BTN_MODE);                   // Inicializa pin BTN_MODE\n    gpio_set_dir(BTN_MODE, GPIO_IN);       // Configura como entrada\n    gpio_pull_up(BTN_MODE);                // Habilita resistencia interna pull-up (estado inactivo = 1)\n\n    gpio_init(BTN_NEXT);                   // Repite para BTN_NEXT\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    gpio_init(BTN_PREV);                   // Repite para BTN_PREV\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    // Configurar interrupci\u00f3n para BTN_MODE\n    gpio_set_irq_enabled(BTN_MODE, GPIO_IRQ_EDGE_FALL, true); // Habilita IRQ en flanco de bajada (bot\u00f3n presionado -&gt; GND)\n    gpio_set_irq_callback(gpio_callback); // Registra la funci\u00f3n callback para IRQs GPIO (llamada global en este SDK)\n    irq_set_enabled(IO_IRQ_BANK0, true);  // Habilita las interrupciones del banco de IO (necesario para que se ejecuten)\n\n    string mensaje_usb = \"\";               // Buffer para recibir caracteres desde USB (comando acumulado)\n    bool btn_next_prev = false;            // Estado previo del bot\u00f3n NEXT (para detectar flancos)\n    bool btn_prev_prev = false;            // Estado previo del bot\u00f3n PREV (para detectar flancos)\n\n    while (true) {                         // Bucle principal infinito\n        // Leer comandos por USB\n        int ch = getchar_timeout_us(1000); // Lee 1 car\u00e1cter con timeout de 1000 us (1 ms)\n        if (ch != PICO_ERROR_TIMEOUT) {   // Si se ley\u00f3 un car\u00e1cter v\u00e1lido\n            if (ch == '\\n' || ch == '\\r') { // Si se presion\u00f3 Enter\n                if (!mensaje_usb.empty()) { // Si hay texto acumulado\n                    procesar_comando(mensaje_usb, slice, chan); // Procesa el comando\n                    mensaje_usb = \"\";      // Limpia el buffer\n                    printf(\"&gt; \");         // Muestra prompt\n                }\n            } else {\n                mensaje_usb += (char)ch;   // Acumula car\u00e1cter en el buffer\n            }\n        }\n\n        // Modo Step (modo 3): mueve al siguiente/anterior cuando se detecta flanco de pulsaci\u00f3n\n        if (modo_actual == 3) {\n            bool btn_next_actual = !gpio_get(BTN_NEXT); // gpio_get devuelve 1 cuando no presionado (pull-up),\n                                                      // invertimos (!) para interpretar pulsado como true.\n            bool btn_prev_actual = !gpio_get(BTN_PREV); // Igual para PREV\n\n            if (btn_next_actual &amp;&amp; !btn_next_prev) { // Detecta flanco de subida (presi\u00f3n nueva)\n                if (posiciones.empty()) {\n                    printf(\"Error no hay pos\\n\");\n                } else {\n                    if (indice_actual &lt; (int)posiciones.size() - 1) { // Si no estamos al final, avanzamos\n                        indice_actual++;\n                    }\n                    mover_servo(slice, chan, posiciones[indice_actual]); // Mueve servo a la nueva posici\u00f3n\n                    printf(\"pos%d: %d\\n\", indice_actual + 1, posiciones[indice_actual]); // Imprime la pos (1-based)\n                }\n            }\n\n            if (btn_prev_actual &amp;&amp; !btn_prev_prev) { // Flanco para PREV\n                if (posiciones.empty()) {\n                    printf(\"Error no hay pos\\n\");\n                } else {\n                    if (indice_actual &gt; 0) {     // Si no estamos al inicio, retrocedemos\n                        indice_actual--;\n                    }\n                    mover_servo(slice, chan, posiciones[indice_actual]); // Mueve servo\n                    printf(\"pos%d: %d\\n\", indice_actual + 1, posiciones[indice_actual]);\n                }\n            }\n\n            btn_next_prev = btn_next_actual;     // Guarda estado actual para detectar flancos en la siguiente iteraci\u00f3n\n            btn_prev_prev = btn_prev_actual;\n        }\n\n        // Modo Continuo (modo 2): recorre todas las posiciones mientras ciclo_activo siga true\n        if (modo_actual == 2 &amp;&amp; ciclo_activo) {\n            if (posiciones.empty()) {\n                printf(\"Error no hay pos\\n\");\n                sleep_ms(1500);                // Espera 1.5 s antes de intentar de nuevo (evita loop r\u00e1pido de errores)\n            } else {\n                for (int i = 0; i &lt; (int)posiciones.size(); i++) { // Recorre todas las posiciones\n                    if (!ciclo_activo) break;   // Si ciclo_activo cambi\u00f3 (por pulsar mode), salimos\n                    mover_servo(slice, chan, posiciones[i]); // Mover servo a la posici\u00f3n i\n                    printf(\"pos%d: %d\\n\", i + 1, posiciones[i]);\n\n                    absolute_time_t start_time = get_absolute_time(); // Marca tiempo de inicio\n                    // Espera 1.5 s (1500000 us) de forma no bloqueante absoluta:\n                    while (absolute_time_diff_us(start_time, get_absolute_time()) &lt; 1500000) {\n                        sleep_ms(100);         // Pausa peque\u00f1a dentro del loop para que el MCU no consuma 100% CPU\n                        if (!ciclo_activo) break; // Permite salir r\u00e1pido si se desactiva ciclo_activo\n                    }\n                }\n            }\n        }\n\n        // Modo Entrenamiento (modo 1): permite mover con botones pero no iterar autom\u00e1ticamente\n        if (modo_actual == 1 &amp;&amp; !posiciones.empty()) {\n            bool btn_next_actual = !gpio_get(BTN_NEXT); // Lectura bot\u00f3n NEXT (presionado -&gt; true)\n            bool btn_prev_actual = !gpio_get(BTN_PREV); // Lectura bot\u00f3n PREV\n\n            if (btn_next_actual &amp;&amp; !btn_next_prev) { // Flanco nuevo\n                if (indice_actual &lt; (int)posiciones.size() - 1) {\n                    indice_actual++;\n                }\n                mover_servo(slice, chan, posiciones[indice_actual]); // Mueve servo a la posici\u00f3n actual\n                printf(\"Servo a %d\u00b0 (pos%d)\\n\", posiciones[indice_actual], indice_actual + 1);\n            }\n\n            if (btn_prev_actual &amp;&amp; !btn_prev_prev) { // Flanco nuevo para PREV\n                if (indice_actual &gt; 0) {\n                    indice_actual--;\n                }\n                mover_servo(slice, chan, posiciones[indice_actual]);\n                printf(\"Servo a %d\u00b0 (pos%d)\\n\", posiciones[indice_actual], indice_actual + 1);\n            }\n\n            btn_next_prev = btn_next_actual;       // Actualiza estados anteriores\n            btn_prev_prev = btn_prev_actual;\n        }\n\n        sleep_ms(10);                             // Peque\u00f1a pausa para evitar busy-loop agresivo\n    }\n\n    return 0; // No se alcanza porque while(true) es infinito, pero es buena pr\u00e1ctica devolver int\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/OutputsBasicos/","title":"\ud83d\udce4 Outputs B\u00e1sicos","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#garcia-cortez-juan-david-sistemas-embebidos-1-27082025","title":"Garcia Cortez Juan David \u00b7  Sistemas Embebidos 1  \u00b7  27/08/2025","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#contador-binario-4-bits","title":"Contador Binario 4 bits","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#en-cuatro-leds-debe-mostrarse-cad-segundo-la-representacion-binaria-del-0-al-15","title":"En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#_1","title":"\ud83d\udce4 Outputs B\u00e1sicos","text":""},{"location":"Sistemas%20Embebidos/OutputsBasicos/#conclusiones","title":"Conclusiones","text":"<ul> <li>Para un proyecto como una conosla de mezclas de m\u00fasica, la ESP32, resulta como la mejor opci\u00f3n, dado a su versatilidad y conectividad WiFi/Bluetooth integrado, facilitando la integraci\u00f3n y comunicaci\u00f3n con otros dispositivos. La Raspberry Pi Pico tambi\u00e9n es una opci\u00f3n flexible y potente, especialmente si se requiere procesamiento en paralelo o facilidad de programaci\u00f3n con MicroPython. Seguido de, tenemos la STM32F103C8T6 que es ideal para apliacaciones m\u00e1s industriales,pero no cuenta con una conectividad inal\u00e1mbrica, y su programaci\u00f3n puede llegar a ser m\u00e1s compleja. Finalmente, el ATmega328P puede quedarse corto para este tipo de proyectos, ya que se dificulta al manejar m\u00faltiples dispositivos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea1/","title":"\ud83e\udd16 Tarea 1: Tabla comparativa","text":"<p>Garcia Cortez Juan David \u00b7  Sistemas Embebidos 1  \u00b7  25/08/2025.</p> No. Microcontrolador Perif\u00e9ricos Memoria Ecosistema Costos Arquitectura Velocidad de Trabajo 01 ESP32 (Espressif) 45 GPIO programables, SPI, I2C, I2S, UART, PWM, ADC, DAC, RMT, SD/MMC, CAN, sensores t\u00e1ctiles, Hall sensor 512 KB de SRAM interna, 448 KB de ROM, memoria Flash externa Compatible con Arduino, ESP-IDF, MicroPython, FreeRTOS $120 - $200 MXN Xtensa LX6 (32 bits, dual core) Hasta 240 MHz 02 Raspberry Pi Pico (RP2040) 26 GPIO, SPI, I2C, UART, PWM, ADC, temporizadores 264 KB de SRAM, memoria Flash externa (2 MB t\u00edpica) Compatible con C/C++, MicroPython, CircuitPython $100 - $150 MXN ARM Cortex-M0+ (32 bits, dual core) Hasta 133 MHz 03 STM32F103C8T6 37 GPIO, SPI, I2C, USART, PWM, ADC, DAC, temporizadores, CAN, USB 20 KB SRAM, 64 KB Flash Compatible con STM32Cube, Arduino, Mbed, PlatformIO $60 - $120 MXN ARM Cortex-M3 (32 bits, single core) Hasta 72 MHz 04 ATmega328 23 GPIO, SPI, I2C, UART, PWM, ADC, temporizadores 2 KB SRAM, 32 KB Flash, 1 KB EEPROM Compatible con Arduino, AVR-GCC $50 - $90 MXN AVR (8 bits, single core) Hasta 20 MHz <p>Perif\u00e9ricos: M\u00f3dulos Integrados que permiten interactuar con el mundo f\u00edsico.</p>"},{"location":"Sistemas%20Embebidos/Tarea1/#conclusiones","title":"Conclusiones","text":"<ul> <li>Para un proyecto como una conosla de mezclas de m\u00fasica, la ESP32, resulta como la mejor opci\u00f3n, dado a su versatilidad y conectividad WiFi/Bluetooth integrado, facilitando la integraci\u00f3n y comunicaci\u00f3n con otros dispositivos. La Raspberry Pi Pico tambi\u00e9n es una opci\u00f3n flexible y potente, especialmente si se requiere procesamiento en paralelo o facilidad de programaci\u00f3n con MicroPython. Seguido de, tenemos la STM32F103C8T6 que es ideal para apliacaciones m\u00e1s industriales,pero no cuenta con una conectividad inal\u00e1mbrica, y su programaci\u00f3n puede llegar a ser m\u00e1s compleja. Finalmente, el ATmega328P puede quedarse corto para este tipo de proyectos, ya que se dificulta al manejar m\u00faltiples dispositivos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/","title":"\ud83e\udd16 Tarea 2: Outputs B\u00e1sicos","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea2/#contador-binario-4-bits","title":"Contador Binario 4 bits","text":"<ul> <li>En 4 leds debe mostrarse cada segundo de la presentaci\u00f3n binaria del 0 al 15</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define Led1 6   // (Less Significant Bit)\n#define Led2 7   // \n#define Led3 8   // \n#define Led4 9   // (Most Significant Bit)\n\nint main() {\n    // M\u00e1scara con los 4 LEDs\n    const uint32_t Mascara = (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4); //Aqui se define que leds vamos a ocupar\n\n    gpio_init_mask(Mascara); // Inicializamos los pines\n    gpio_set_dir_masked(Mascara, Mascara); // Definimos todos como salida, utilizando 1u que se mostro arriba\n\n    int contador = 0;  // Iniciamos el contador en 0\n\n    while (true) {\n        // Poner en LEDs el valor del contador\n        gpio_put_masked(Mascara, (contador &lt;&lt; Led1));\n\n        sleep_ms(1000); // 1 segundo\n\n        contador++;\n        if (contador &gt; 15) { // Reinicia al llegar a 15\n            contador = 0;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea2/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea2/#barrido-de-leds","title":"Barrido de leds","text":"<ul> <li>Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n#include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n\n#define Led1 6\n#define Led2 7\n#define Led3 8\n#define Led4 9\n#define Led5 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5)); // Configura los pines como salida\n\n\n    int posicion = 6;\n\n    int direccion = 1; // 1 para derecha, -1 para izquierda\n\n    while (true)\n    {\n        gpio_put_masked(Mascara, (1u &lt;&lt; posicion)); // Enciende el LED en la posici\u00f3n actual\n        sleep_ms(200);                             // Pausa de 200 ms\n\n        posicion += direccion; // Actualiza la posici\u00f3n\n        if (posicion == Led5) direccion = -1;\n        else if (posicion == Led1) direccion = 1;\n\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea2/#video_1","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea2/#secuencia-en-codigo-gray","title":"Secuencia en codigo Gray","text":"<ul> <li>Mostrar la secuencia del 0 al 15 en forma de c\u00f3digo Gray</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea2/#codigo_2","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define Led1 6   // (LSB)\n#define Led2 7   \n#define Led3 8   \n#define Led4 9   // (MSB)\n\nint main() {\n    const uint32_t Mascara = (1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4);\n\n    gpio_init_mask(Mascara);\n    gpio_set_dir_masked(Mascara, Mascara);\n\n    int contador = 0;\n\n    while (true) {\n        // Convertir de binario a Gray\n        int gray = contador ^ (contador &gt;&gt; 1);\n\n        // Mandar a los LEDs\n        gpio_put_masked(Mascara, (gray &lt;&lt; Led1));\n\n        sleep_ms(1000);\n\n        contador++;\n        if (contador &gt; 15) {\n            contador = 0;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea2/#video_2","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea3/","title":"\ud83e\udd16 Tarea 3: Inputs","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea3/#compuertas-basicas-and-or-xor-con-2-botones","title":"Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<ul> <li>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea3/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n// #include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n#define BotonX 4\n#define BotonY 5\n#define LedX 6\n#define LedY 7\n#define LedZ_AND 8\n#define LedZ_OR 9\n#define LedZ_XOR 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; BotonX | 1u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (0u &lt;&lt; BotonX | 0u &lt;&lt; BotonY | 1u &lt;&lt; LedX | 1u &lt;&lt; LedY | 1u &lt;&lt; LedZ_AND | 1u &lt;&lt; LedZ_OR | 1u &lt;&lt; LedZ_XOR)); // Configura los pines como salida\n    gpio_pull_up(BotonX);                                                                                                                    // Activa la resistencia pull-up interna del pin 4\n    gpio_pull_up(BotonY);\n\n    while (true)\n    {\n        int Entrada_X = !gpio_get(BotonX);\n        int Entrada_Y = !gpio_get(BotonY);\n        int Salida_AND, Salida_OR, Salida_XOR;\n\n        Salida_AND = Entrada_X &amp; Entrada_Y; // Pin 8 = Pin 4 AND Pin 5\n        Salida_OR = Entrada_X | Entrada_Y;  // Pin 9 = Pin 4 OR Pin 5\n        Salida_XOR = Entrada_X ^ Entrada_Y; // Pin 10 = Pin 4 XOR Pin 5\n\n        gpio_put_masked(Mascara, (1 &lt;&lt; 11) | (Entrada_X &lt;&lt; LedX) | (Entrada_Y &lt;&lt; LedY) | (Salida_AND &lt;&lt; LedZ_AND) | (Salida_OR &lt;&lt; LedZ_OR) | (Salida_XOR &lt;&lt; LedZ_XOR));\n        sleep_ms(100); // Pausa de 100 ms\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea3/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea3/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea3/#selector-ciclico-de-5-leds-con-avanceretroceso","title":"Selector c\u00edclico de 5 LEDs con avance/retroceso","text":"<ul> <li>Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21924\u21920) y otro RETROCEDE (0\u21924\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea3/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\" // Para usar las funciones de GPIO\n// #include \"hardware/gpio.h\"        // Para usar las funciones de GPIO\n\n#define BotonX 4\n#define BotonY 5\n#define Led1 6\n#define Led2 7\n#define Led3 8\n#define Led4 9\n#define Led5 10\n\nint main()\n{\n    const uint32_t Mascara = (1u &lt;&lt; BotonX | 1u &lt;&lt; BotonY | 1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5);\n\n    gpio_init_mask(Mascara);                                                                                                                 // Inicializa los pines\n    gpio_set_dir_masked(Mascara, (0u &lt;&lt; BotonX | 0u &lt;&lt; BotonY | 1u &lt;&lt; Led1 | 1u &lt;&lt; Led2 | 1u &lt;&lt; Led3 | 1u &lt;&lt; Led4 | 1u &lt;&lt; Led5)); // Configura los pines como salida\n    gpio_pull_up(BotonX);                                                                                                                    // Activa la resistencia pull-up interna del pin 4\n    gpio_pull_up(BotonY);\n\n    int posicion = 6;\n    bool presionado = false;\n\n    while (true)\n    {\n        int Boton_Izq = !gpio_get(BotonX);\n        int Boton_Der = !gpio_get(BotonY);\n\n        if (Boton_Izq == 1 &amp;&amp; presionado == false)\n        {\n            presionado = true;\n            if (posicion == 6)\n                posicion = 11;\n            posicion--;\n        }\n        if (Boton_Der == 1 &amp;&amp; presionado == false)\n        {\n            presionado = true;\n            if (posicion == 10)\n                posicion = 5;\n            posicion++;\n        }\n        if (Boton_Izq == 0 &amp;&amp; Boton_Der == 0)\n            presionado = false;\n        gpio_put_masked(Mascara, (1u &lt;&lt; posicion)); // Enciende el LED en la posici\u00f3n actual\n        sleep_ms(10);                              // Pausa de 100 ms\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea3/#esquematico_1","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea3/#video_1","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea4/","title":"\ud83e\udd16 Tarea 4: Pong","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea4/#programar-un-mini-pong-con-5-leds-en-linea-y-2-botones-usando-interrupciones-isr-para-registrar-el-golpe-del-jugador-exactamente-cuando-la-pelota-un-led-encendido-llega-al-extremo-de-su-lado","title":"Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.","text":""},{"location":"Sistemas%20Embebidos/Tarea4/#reglas-del-juego","title":"Reglas del juego","text":"<ul> <li> <p>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</p> </li> <li> <p>Golpe con ISR: cada bot\u00f3n genera una interrupci\u00f3n.</p> </li> <li> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> </li> <li> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> </li> <li> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> </li> <li> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> </li> <li> <p>Fallo y punto: si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto: al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto: despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego: al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea4/#codigo","title":"C\u00f3digo","text":"<pre><code>// tarea4.c\n\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n// Pines\n#define P1 4\n#define P2 5\n#define WIN1 6\n#define LED1 7\n#define LED2 8\n#define LED3 9\n#define LED4 10\n#define LED5 11\n#define WIN2 12\n\n// Flags de interrupci\u00f3n\nvolatile bool flag_p1 = false;\nvolatile bool flag_p2 = false;\n\n// Funci\u00f3n para parpadear LED ganador\nvoid parpadear_led(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(200);\n        gpio_put(led, 0);\n        sleep_ms(200);\n    }\n}\n\n// Callback de interrupci\u00f3n\nvoid gpio_callback(uint gpio, uint32_t events) {\n    if (events &amp; GPIO_IRQ_EDGE_RISE) {\n        if (gpio == P1) flag_p1 = true;\n        else if (gpio == P2) flag_p2 = true;\n    }\n}\n\nint main() {\n    // Inicializar LEDs\n    const uint32_t LED_MASK = (1u &lt;&lt; WIN1) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) |\n                               (1u &lt;&lt; LED4) | (1u &lt;&lt; LED5) | (1u &lt;&lt; WIN2);\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_masked(LED_MASK, LED_MASK);\n\n    // Inicializar botones\n    gpio_init(P1); gpio_set_dir(P1, GPIO_IN); gpio_pull_down(P1); //tambien tiene pulldown externo\n    gpio_init(P2); gpio_set_dir(P2, GPIO_IN); gpio_pull_down(P2);\n    gpio_set_irq_enabled_with_callback(P1, GPIO_IRQ_EDGE_RISE, true, &amp;gpio_callback);\n    gpio_set_irq_enabled(P2, GPIO_IRQ_EDGE_RISE, true);\n\n    int ultima_direccion = 1; // 1: derecha (jugador 2), -1: izquierda (jugador 1)\n    bool primer_jugada = true; // &lt;--- NUEVO\n\n    while (true) {\n        gpio_put_masked(LED_MASK, 0); // Apagar todos los LEDs\n        gpio_put(LED3, 1); // Encender LED3 del medio\n\n        // Esperar a que se presione cualquier bot\u00f3n antes de iniciar la secuencia\n        while (gpio_get(P1) == 0 &amp;&amp; gpio_get(P2) == 0) {\n            sleep_ms(10);\n        }\n\n        // Apagar LED3 antes de iniciar la secuencia\n        gpio_put(LED3, 0);\n\n        int direccion_inicial;\n        if (primer_jugada) {\n            // Primera jugada: direcci\u00f3n hacia el jugador que NO presion\u00f3 el bot\u00f3n\n            if (gpio_get(P1) == 1) {\n                direccion_inicial = 1;  // P1 presion\u00f3, va hacia P2\n            } else if (gpio_get(P2) == 1) {\n                direccion_inicial = -1; // P2 presion\u00f3, va hacia P1\n            } else {\n                direccion_inicial = ultima_direccion; // Por si acaso\n            }\n            primer_jugada = false;\n        } else {\n            // Siguientes jugadas: direcci\u00f3n hacia el ganador anterior\n            direccion_inicial = ultima_direccion;\n        }\n\n        int posicion = LED3;\n        int direccion = direccion_inicial;\n        flag_p1 = false;\n        flag_p2 = false;\n\n        int prev_p1 = 1, prev_p2 = 1;\n\n        while (1) {\n            gpio_put_masked(LED_MASK, 0);\n\n            if (posicion &gt;= LED1 &amp;&amp; posicion &lt;= LED5) {\n                gpio_put(posicion, 1);\n            }\n            sleep_ms(400);\n\n            int curr_p1 = gpio_get(P1);\n            int curr_p2 = gpio_get(P2);\n\n            if (posicion == LED1 &amp;&amp; prev_p1 == 1 &amp;&amp; curr_p1 == 0) {\n                direccion = 1;\n            } else if (posicion == LED5 &amp;&amp; prev_p2 == 1 &amp;&amp; curr_p2 == 0) {\n                direccion = -1;\n            }\n\n            prev_p1 = curr_p1;\n            prev_p2 = curr_p2;\n\n            // Verificar victoria\n            if (posicion == WIN1) {\n                gpio_put_masked(LED_MASK, 0);\n                parpadear_led(WIN2);\n                ultima_direccion = 1; // Ahora la siguiente ronda va hacia jugador 2\n                break;\n            } else if (posicion == WIN2) {\n                gpio_put_masked(LED_MASK, 0);\n                parpadear_led(WIN1);\n                ultima_direccion = -1; // Ahora la siguiente ronda va hacia jugador 1\n                break;\n            }\n\n            posicion += direccion;\n        }\n        sleep_ms(500); // Espera antes de reiniciar el juego\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea4/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea4/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea5/","title":"\ud83e\udd16 Tarea 5: Ejercicio de Medici\u00f3n.","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  15/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea5/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<ul> <li> <p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> </li> <li> <p>Periodo promedio y tolerancia.</p> </li> <li> <p>Jitter pico-a-pico y, si tu equipo lo permite, RMS.  Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#codigo","title":"C\u00f3digo","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 6\nstatic const int BLINK_MS = 100;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea5/#imagen-del-osciloscopio","title":"Imagen del Osciloscopio","text":"<ul> <li>El osciloscopio se encuentra con una escala del 50X, a una posici\u00f3n de 2.58 microsegundos. Una diferencia de tiempo de 100 microsegundos y una diferencia de voltaje de 37.19 mV</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<ul> <li> <p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> </li> <li> <p>Usa rearme acumulativo.</p> </li> <li> <p>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico.</p> </li> <li> <p>Con el osciloscopio, mide y registra para cada modo:</p> </li> <li> <p>Periodo promedio y desviaci\u00f3n respecto al nominal.</p> </li> <li> <p>Jitter pico-a-pico y/o RMS.</p> </li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#codigo-con-microsegundos","title":"C\u00f3digo con microsegundos","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       6\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 400u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea5/#imagen-del-osciloscopio_1","title":"Imagen del Osciloscopio","text":""},{"location":"Sistemas%20Embebidos/Tarea5/#codigo-con-ciclos","title":"C\u00f3digo con Ciclos","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       6\n#define ALARM_NUM     0  // usaremos la alarma 0\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\n#define CLK_SYS_HZ    150000000u\nstatic volatile uint32_t next_deadline;   \nstatic volatile uint32_t intervalo_ciclos = (CLK_SYS_HZ /1000000u)* 400000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_ciclos;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    timer_hw-&gt;timerctrl = TIMER_TIMERCTRL_CLK_SYS_BITS;\n\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_cycles = timer_hw-&gt;timerawl;          \n    next_deadline = now_cycles + intervalo_ciclos;         \n\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea5/#imagen-del-osciloscopio_2","title":"Imagen del Osciloscopio","text":"<ul> <li>Podemos concluir que el uso de los ciclos es m\u00e1s exacto y preciso para analizar se\u00f1ales r\u00e1pidas y medir variaciones entre ciclos individuales. Ya que en ambos casos se utilizaron 400 milisegundos, pero notamos que la diferencia de tiempo fue m\u00e1s cercana al valor te\u00f3rico en el caso de los ciclos.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea5/#esquematico-utilizado-en-la-practica","title":"Esquem\u00e1tico Utilizado en la Pr\u00e1ctica","text":""},{"location":"Sistemas%20Embebidos/Tarea6/","title":"\ud83e\udd16 Tarea 6: Ejercicios de Programaci\u00f3n","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  16/09/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea6/#ejercicio-1","title":"Ejercicio 1","text":"<ul> <li>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea6/#codigo-que-debia-funcionar","title":"C\u00f3digo que deb\u00eda funcionar","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     6   \n#define LED1_PIN     7\n#define LED2_PIN     8\n#define LED3_PIN     9                     \n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n#define ALARM3_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM3_NUM)\n\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us, next2_us, next3_us;\nstatic const uint32_t INTERVALO0_US = 250u;\nstatic const uint32_t INTERVALO1_US = 400u;\nstatic const uint32_t INTERVALO2_US = 500u;\nstatic const uint32_t INTERVALO3_US = 800u;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\n// ISR para ALARM2\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\n// ISR para ALARM3\nstatic void on_alarm3_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM3_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n    next3_us += INTERVALO3_US;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n}\n\nint main() {\n\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n    gpio_init(LED3_PIN);\n    gpio_set_dir(LED3_PIN, GPIO_OUT);\n    gpio_put(LED3_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    // Programa ambas alarmas\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n    irq_set_exclusive_handler(ALARM3_IRQ, on_alarm3_irq);\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Habilita ambas IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n    irq_set_enabled(ALARM3_IRQ, true);\n\n    // Bucle principal: todo el parpadeo ocurre en las ISRs\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea6/#codigo-que-funciono","title":"C\u00f3digo que funcion\u00f3","text":"<pre><code>// Tres LEDs con alarmas del timer + un LED controlado por polling en el main loop\n// - ALARM0 controla el LED en GPIO 6\n// - ALARM1 controla el LED en GPIO 7\n// - ALARM2 controla el LED en GPIO 8\n// - GPIO 9 se controla por polling en el bucle principal\n\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n// Definici\u00f3n de pines para los LEDs\n#define LED0_PIN     6  // LED en GPIO 6 (ALARM0)\n#define LED1_PIN     7  // LED en GPIO 7 (ALARM1)\n#define LED2_PIN     8  // LED en GPIO 8 (ALARM2)\n#define LED3_PIN     9  // LED en GPIO 9 (polling)\n\n// N\u00fameros de alarma (solo existen 0, 1, 2)\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n\n// IRQs para cada alarma\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us, next2_us;\nstatic const uint32_t INTERVALO0_US = 250000u;  // 250 ms\nstatic const uint32_t INTERVALO1_US = 400000u;  // 400 ms\nstatic const uint32_t INTERVALO2_US = 600000u;  // 600 ms\nstatic const uint32_t INTERVALO3_US = 1000000u; // 1000 ms\n\n// Para el LED controlado por polling\nstatic volatile uint32_t next_poll_us = 0;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\n\n// ISR para ALARM2\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\n\nint main() {\n    // Configuraci\u00f3n de los pines de los LEDs\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n    gpio_init(LED3_PIN);\n    gpio_set_dir(LED3_PIN, GPIO_OUT);\n    gpio_put(LED3_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines para cada alarma\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next_poll_us = now_us + INTERVALO3_US;\n\n    // Programa las tres alarmas disponibles\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | \n                                   (1u &lt;&lt; ALARM2_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | \n                                 (1u &lt;&lt; ALARM2_NUM));\n\n    // Habilita todas las IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n\n    // Bucle principal: controlamos el cuarto LED por polling\n    while (true) {\n        uint32_t current_time = timer_hw-&gt;timerawl;\n\n        // Control por polling del cuarto LED\n        if ((int32_t)(current_time - next_poll_us) &gt;= 0) {\n            sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n            next_poll_us += INTERVALO3_US;\n        }\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea6/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea6/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea6/#ejercicio-2","title":"Ejercicio 2","text":"<ul> <li>Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea6/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n// Pines\n#define P1 4\n#define P2 5\n#define WIN1 6\n#define LED1 7\n#define LED2 8\n#define LED3 9\n#define LED4 10\n#define LED5 11\n#define WIN2 12\n#define BTN_SLOW 14\n#define BTN_FAST 15\n\n#define ALARM0_NUM 0\n#define ALARM0_IRQ timer_hw-&gt;intr\n\n// LEDs\nconst uint LEDS[] = {WIN1, LED1, LED2, LED3, LED4, LED5, WIN2};\n\n// Estado del juego\nvolatile int posicion = LED3;\nvolatile int direccion = 1;\nvolatile bool flag_p1 = false;\nvolatile bool flag_p2 = false;\nvolatile bool flag_slow = false;\nvolatile bool flag_fast = false;\nvolatile bool juego_activo = true;\n\n// Intervalo de movimiento en \u00b5s\nvolatile uint32_t intervalo_us = 200000;\nvolatile uint32_t next_alarm_us = 0;\n\n// Parpadeo de LED ganador\nvoid parpadear_led(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(300);\n        gpio_put(led, 0);\n        sleep_ms(300);\n    }\n}\n\n// Interrupciones GPIO\nvoid gpio_callback(uint gpio, uint32_t events) {\n    if (events &amp; GPIO_IRQ_EDGE_RISE) {\n        if (gpio == P1) flag_p1 = true;\n        else if (gpio == P2) flag_p2 = true;\n        else if (gpio == BTN_SLOW) flag_slow = true;\n        else if (gpio == BTN_FAST) flag_fast = true;\n    }\n}\n\n// Interrupci\u00f3n de ALARM0\nvoid on_alarm0_irq() {\n    // Limpiar flag\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n\n    if (!juego_activo) return;\n\n    // Apagar todos los LEDs\n    for (int i = 0; i &lt; 7; i++) gpio_put(LEDS[i], 0);\n\n    // Encender LED actual\n    gpio_put(posicion, 1);\n\n    // Cambiar direcci\u00f3n solo si el LED est\u00e1 en el extremo\n    if (posicion == LED1) {\n        if (flag_p1) {\n            direccion = 1;\n            flag_p1 = false;\n        }\n    } else if (posicion == LED5) {\n        if (flag_p2) {\n            direccion = -1;\n            flag_p2 = false;\n        }\n    }\n\n    // Ajustar velocidad\n    if (flag_slow) {\n        intervalo_us += 50000;\n        if (intervalo_us &gt; 1000000) intervalo_us = 1000000;\n        flag_slow = false;\n    }\n    if (flag_fast) {\n        if (intervalo_us &gt; 50000) intervalo_us -= 50000;\n        flag_fast = false;\n    }\n\n    // Verificar victoria\n    if (posicion == WIN1) {\n        parpadear_led(WIN2);\n        juego_activo = false;\n        direccion = 1;\n        return;\n    } else if (posicion == WIN2) {\n        parpadear_led(WIN1);\n        juego_activo = false;\n        direccion = -1;\n        return;\n    }\n\n    // Mover LED\n    posicion += direccion;\n\n    // Reprogramar alarma\n    next_alarm_us += intervalo_us;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next_alarm_us;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar LEDs\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], GPIO_OUT);\n        gpio_put(LEDS[i], 0);\n    }\n\n    // Inicializar botones\n    gpio_init(P1); gpio_set_dir(P1, GPIO_IN); gpio_pull_up(P1);\n    gpio_init(P2); gpio_set_dir(P2, GPIO_IN); gpio_pull_up(P2);\n    gpio_init(BTN_SLOW); gpio_set_dir(BTN_SLOW, GPIO_IN); gpio_pull_up(BTN_SLOW);\n    gpio_init(BTN_FAST); gpio_set_dir(BTN_FAST, GPIO_IN); gpio_pull_up(BTN_FAST);\n\n    // Configurar interrupciones GPIO\n    gpio_set_irq_enabled_with_callback(P1, GPIO_IRQ_EDGE_RISE, true, &amp;gpio_callback);\n    gpio_set_irq_enabled(P2, GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN_SLOW, GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN_FAST, GPIO_IRQ_EDGE_RISE, true);\n\n    // Configurar TIMER\n    timer_hw-&gt;source = 0u;\n    irq_set_exclusive_handler(timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM), on_alarm0_irq);\n    irq_set_enabled(timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM), true);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM0_NUM);\n\n    while (true) {\n        // Reiniciar estado\n        posicion = LED3;\n        juego_activo = true;\n        intervalo_us = 200000;\n\n        // Programar primera alarma\n        next_alarm_us = timer_hw-&gt;timerawl + intervalo_us;\n        timer_hw-&gt;alarm[ALARM0_NUM] = next_alarm_us;\n\n        // Esperar fin del juego\n        while (juego_activo) {\n            tight_loop_contents();\n        }\n\n        sleep_ms(1000); // Espera antes de reiniciar\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea6/#esquematico_1","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea6/#video_1","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea7.1/","title":"\ud83e\udd16 Tarea 7.1: PWM","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/10/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#control-de-duty-cycle-motor-dc","title":"Control de Duty Cycle \u2014 Motor DC","text":"<ul> <li>Entregable: </li> <li>Implementar un circuito con un motor DC controlado mediante PWM  variando el duty cycle. </li> <li> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> </li> <li> <p>Documentar:</p> </li> <li> <p>Valores de duty usados, con el porque.</p> </li> <li>No olvidar que el microcontrolador no entrega suficiente potencia, se debe usar un puente H o driver de motor para conectar el motor DC.</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define ENA 2       // Pin PWM (velocidad del motor)\n#define IN1 3       // Direcci\u00f3n (H-Bridge)\n#define IN2 4       // Direcci\u00f3n (H-Bridge)\n#define BTN_UP 14   // Bot\u00f3n para subir velocidad\n#define BTN_DOWN 15 // Bot\u00f3n para bajar velocidad\n\n#define F_PWM_HZ 2000   // Frecuencia de PWM\n#define TOP 1023        // Resoluci\u00f3n de 10 bits (0\u20131023)\n\n// Valores de duty cycle (equivalentes a 40%, 60% y 80%)\nconst uint16_t duty_values[] = {410, 615, 820};\n\nint speed_index = 1;  // Empezar en el valor medio (60%)\n\nbool last_up = true;\nbool last_down = true;\n\n// -----------------------------------------------------\n// Funci\u00f3n para establecer la velocidad del motor (duty cycle)\n// -----------------------------------------------------\nvoid set_motor_speed(uint slice, uint chan, uint16_t duty) {\n    // Si el duty es bajo, hacer un \u201carranque forzado\u201d al 100%\n    if (duty &gt; 0 &amp;&amp; duty &lt;= 410) { // equivalente al 40%\n        pwm_set_chan_level(slice, chan, TOP); // duty = 100%\n        sleep_ms(100);\n    }\n\n    pwm_set_chan_level(slice, chan, duty);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configurar pines de direcci\u00f3n\n    gpio_init(IN1);\n    gpio_set_dir(IN1, GPIO_OUT);\n    gpio_put(IN1, 1);\n\n    gpio_init(IN2);\n    gpio_set_dir(IN2, GPIO_OUT);\n    gpio_put(IN2, 0);\n\n    // Configurar botones\n    gpio_init(BTN_UP);\n    gpio_set_dir(BTN_UP, GPIO_IN);\n    gpio_pull_up(BTN_UP);\n\n    gpio_init(BTN_DOWN);\n    gpio_set_dir(BTN_DOWN, GPIO_IN);\n    gpio_pull_up(BTN_DOWN);\n\n    // Configurar PWM\n    gpio_set_function(ENA, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(ENA);\n    uint chan  = pwm_gpio_to_channel(ENA);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    // Iniciar en velocidad media\n    set_motor_speed(slice, chan, duty_values[speed_index]);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        bool up_now = gpio_get(BTN_UP);\n        bool down_now = gpio_get(BTN_DOWN);\n\n        // Bot\u00f3n UP\n        if (last_up &amp;&amp; !up_now) {\n            sleep_ms(50);\n            if (!gpio_get(BTN_UP)) {\n                if (speed_index &lt; 2) speed_index++;\n                set_motor_speed(slice, chan, duty_values[speed_index]);\n            }\n        }\n\n        // Bot\u00f3n DOWN\n        if (last_down &amp;&amp; !down_now) {\n            sleep_ms(50);\n            if (!gpio_get(BTN_DOWN)) {\n                if (speed_index &gt; 0) speed_index--;\n                set_motor_speed(slice, chan, duty_values[speed_index]);\n            }\n        }\n\n        last_up = up_now;\n        last_down = down_now;\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#valores-de-duty-usados","title":"Valores de duty usados","text":"<ul> <li> <p>410 / 1023 \u00d7 100 \u2248 40%</p> </li> <li> <p>615 / 1023 \u00d7 100 \u2248 60%</p> </li> <li> <p>820 / 1023 \u00d7 100 \u2248 80%</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.1/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea7.1/#video","title":"Video","text":""},{"location":"Sistemas%20Embebidos/Tarea7.2/","title":"\ud83e\udd16 Tarea 7.2: PWM","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/10/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#control-con-frecuencia-buzzer","title":"Control con frecuencia buzzer","text":"<ul> <li> <p>Entregable:</p> </li> <li> <p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> </li> <li> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> </li> <li> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> </li> <li> <p>Documentar:</p> </li> <li> <p>Tabla con notas, frecuencias y duraci\u00f3n usadas.</p> </li> <li> <p>Evidencia en audio o video de la melod\u00eda funcionando.</p> </li> <li> <p>Recomendaci\u00f3n: La mejor frecuencia de trabajo del buzzer es t\u00edpicamente entre 532 Hz y 4 kHz y adaptar las notas a una octava que suene clara en ese rango.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 2\n#define TOP 2048\n\n// Notas de TU melod\u00eda\n#define FAs 740.0f\n#define RE  587.0f  \n#define SI  494.0f\n#define MI  659.0f\n#define SOLs 831.0f\n#define LA  880.0f\n#define DOs 988.0f\n\n// Duraciones\n#define CORCHEA 214 //duraci\u00f3n de una nota en ms, corchea es nota musical \n#define SILENCIO 214  // Los espacios son silencios de 214ms\n#define SILENCIO_MENOR 50 //Silencio de 50ms\n\nvoid tocar_nota(uint slice, uint chan, float frecuencia, int duracion) {\n    if (frecuencia &gt; 1.0f) {\n        float f_clk = 125000000.0f;\n        float div = f_clk / (frecuencia * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, TOP / 2); //duty al 50%\n        sleep_ms(duracion);\n        pwm_set_chan_level(slice, chan, 0);\n    }\n    sleep_ms(10); // Peque\u00f1a pausa entre notas\n}\n\nvoid tocar_silencio(int duracion) {\n    sleep_ms(duracion);\n} //duraci\u00f3n de silencio\n\nvoid tocar_melodia(uint slice, uint chan) {\n    // FA#FA#RESI\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, RE, CORCHEA);\n    tocar_nota(slice, chan, SI, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // SI\n    tocar_nota(slice, chan, SI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    //MI\n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // MI \n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    // MI SOL# LA DO#\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, SOLs, CORCHEA);\n    tocar_nota(slice, chan, SOLs, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, DOs, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO_MENOR);\n\n    // LALA LAMI\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, LA, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, RE, CORCHEA);\n\n    // SILENCIO (espacio)\n    tocar_silencio(SILENCIO);\n\n    // FA#FA#\n    tocar_nota(slice, chan, FAs, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, FAs, CORCHEA);\n\n    tocar_silencio(SILENCIO);\n\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n    tocar_nota(slice, chan, FAs, CORCHEA);\n    tocar_nota(slice, chan, MI, CORCHEA);\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, TOP / 2);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        tocar_melodia(slice, chan);\n        sleep_ms(2000); // Pausa larga antes de repetir\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#tabla-de-valores","title":"Tabla de valores","text":"<pre><code>| Nota Musical | Duraci\u00f3n| Frecuencia |\n|-------------:|:-------:|:----------:|\n| Fa #         | 214 ms  | 740 Hz     |\n| Re           | 214 ms  | 587 Hz     |\n| Si           | 214 ms  | 494 Hz     |\n| Mi           | 214 ms  | 659 Hz     |\n| Sol#         | 214 ms  | 831 Hz     |\n| La           | 214 ms  | 880 Hz     |\n| Do#          | 214 ms  | 988 Hz     |\n| Silencios    | 214 ms  | -          |\n|Silencio Menor| 214 ms  | -          |\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.2/#esquematico","title":"Esquem\u00e1tico","text":""},{"location":"Sistemas%20Embebidos/Tarea7.2/#audio","title":"Audio","text":""},{"location":"Sistemas%20Embebidos/Tarea7.3/","title":"\ud83e\udd16 Tarea 7.3: Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":"<p>Garcia Cortez Juan David \u00b7 Arai Erazo Sumie \u00b7  Sistemas Embebidos 1  \u00b7  01/10/2025.</p>"},{"location":"Sistemas%20Embebidos/Tarea7.3/#control-con-frecuencia-buzzer","title":"Control con frecuencia buzzer","text":"<ul> <li> <p>Entregable:</p> </li> <li> <p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> </li> <li> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio:</p> </li> <li> <p>Documentar:</p> </li> <li> <p>Capturas de osciloscopio Antes del filtro (PWM) y Despu\u00e9s del filtro.</p> </li> <li> <p>Explicaci\u00f3n de la frecuencia de corte:</p> </li> <li> <p>El filtro RC se dise\u00f1a para dejar pasar se\u00f1ales de 60 Hz y eliminar las componentes de alta frecuencia que provienen del PWM.</p> </li> <li> <p>La frecuencia de corte (fcf_cfc\u200b) es el punto donde el filtro empieza a atenuar las se\u00f1ales. Matem\u00e1ticamente:</p> </li> </ul> <p>\u200b * En este caso, queremos que fc sea un poco mayor que 60 Hz para que nuestra se\u00f1al sinusoidal de 60 Hz no sea atenuada.</p> <ul> <li> <p>Valores recomendados para un fc\u2248100Hz</p> </li> <li> <p>Opci\u00f3n 1: R=2.2\u2009k\u03a9R C=0.68\u2009\u03bcF fc\u2248106Hz.</p> </li> <li> <p>Opci\u00f3n 2: R=1.6\u2009k\u03a9R, C=1\u2009\u03bcF  fc\u2248100Hz</p> </li> <li> <p>Conexion:</p> </li> <li> <p>La salida de PWM entra en la resistencia.</p> </li> <li> <p>Despu\u00e9s de la resistencia, conectar el capacitor a tierra.</p> </li> <li> <p>El punto entre resistencia y capacitor es la salida filtrada, que se conecta al osciloscopio.</p> </li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea7.3/#codigo","title":"C\u00f3digo","text":"<pre><code>// pwm_seno.c \u2014 Generar seno 60 Hz con PWM en GPIO 3\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PIN_PWM    3\n#define FREQ_PWM   2000     // 2 kHz portadora\n#define TOP        1023     // 10 bits de resoluci\u00f3n\n#define FREQ_SENO  60       // Se\u00f1al deseada: 60 Hz\n\n#define PI 3.141592653589793\n\n// N\u00famero de muestras por ciclo de seno\n#define N_MUESTRAS 100\n\nuint16_t tabla_seno[N_MUESTRAS];\n\nint main() {\n    stdio_init_all();\n\n    // --- Generar tabla seno ---\n    for (int i = 0; i &lt; N_MUESTRAS; i++) {\n        float ang = 2 * PI * i / N_MUESTRAS;\n        float val = (sinf(ang) + 1.0f) / 2.0f;  // [0,1]\n        tabla_seno[i] = (uint16_t)(val * TOP);\n    }\n\n    // --- Configuraci\u00f3n PWM ---\n    gpio_set_function(PIN_PWM, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PIN_PWM);\n    uint chan  = pwm_gpio_to_channel(PIN_PWM);\n\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (FREQ_PWM * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_enabled(slice, true);\n\n    // --- Temporizaci\u00f3n para 60 Hz ---\n    // Cada ciclo = 16.67 ms. Dividido en N_MUESTRAS \u2192 periodo de actualizaci\u00f3n:\n    float Ts_ms = 1000.0f / (FREQ_SENO * N_MUESTRAS); // ~0.167 ms (167 \u00b5s)\n\n    int idx = 0;\n    while (true) {\n        pwm_set_chan_level(slice, chan, tabla_seno[idx]);\n        idx = (idx + 1) % N_MUESTRAS;\n        sleep_us((int)(Ts_ms * 1000));\n    }\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos/Tarea7.3/#senal-no-filtrada","title":"Se\u00f1al No Filtrada","text":""},{"location":"Sistemas%20Embebidos/Tarea7.3/#senal-filtrada","title":"Se\u00f1al Filtrada","text":""},{"location":"Sistemas%20Embebidos/Tarea8/","title":"\ud83d\udcda TAREA 8","text":""},{"location":"Sistemas%20Embebidos/Tarea8/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comunicacion uart y usb  </li> <li>Equipo / Autor(es): Juan David Garc\u00eda Cort\u00e9z y Sumie Arai Erazo  </li> <li>Curso / Asignatura: Sistemas embebidos 1  </li> <li>Fecha: 22/10/25  </li> <li>Descripci\u00f3n breve: _En equipos de 4 conectar dos picos por medio de rx y tx bidireccional para intercambiar mensajes escritos en la consolas de las computadoras. _</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea8/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Aprender las utilidades del PWM</li> <li>Espec\u00edficos:</li> <li>Desensamblar y ensamblar strings sin que se corrompan los mensajes_</li> <li>Utilizar frecuencias espec\u00edficas para hacer notas musicales</li> <li>Crear una se\u00f1al sinusoidal a parir de una PWM y un filtro con capacitor y leerla con un osciloscopio</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea8/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>1 capacitor de 1uF, resistencias de 1k y 680 ohms, osciloscopio   -1 buzzer pasivo, 1 resistencia de 220.   -2 botones, resistencias pulldown de 1k, 1 motor DC._</li> </ul>"},{"location":"Sistemas%20Embebidos/Tarea8/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / visual studio / raspberry pi pico. - \"pico/stdlib.h\", \"hardware/structs/sio.h\"</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Sistemas%20Embebidos/Tarea8/#5-codigos","title":"5) C\u00f3digos","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 17\n#define led_PIN 16\nusing namespace std; //USO DE STRING en la terminal \n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART); // DEFINE TX Y RX\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE); //VELOCIDAD DE TRANSMISI\u00d3N, \n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE); //NO QUEREMOS ENCONTRAR ERRORES DE TRANSMISI\u00d3N, para saber como empieza el msj\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\"; // DEFINE C Y P COMO VARIIABLE DE RECONSTRUCCION, C LA RECIBE LA PALABRA  \n    string p=\"\"; //RECONSTRUYE LA PALABRA QUE VAMOS A ENVIAR\n    while (true){\n\n        int ch = getchar_timeout_us(0); //LEE EL CARACTER\n        if (ch != PICO_ERROR_TIMEOUT) { //SI NO HAY ERROR, ENTONCES IMPRIME EL CARACTER\n            printf(\"Eco: %c\\n\", (char)ch); //IMPRIME EL CARACTER DE LA PALABRA RECIBIDA, \n            p+= (char)ch; //RECONSTRUYE LA PALABRA EN P\n\n            if(ch=='.' || ch=='\\n'){ // CUANDO ENTRA UN PUNTO O UN ENTER \n                uart_puts(UART_ID, p.c_str()); //MANDA LA PALABRA P, AL OTRO PICO, CONVIERTE UN STRING EN UN ARREGLO DE CARACTERES\n                p=\"\"; //VACIAMOS LA PALBRA P, PARA ENVIAR UNA NUEVA\n            }\n        }\n        int a;\n        if (gpio_get(button_pin) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");//HACE QUE FUNCIONE EL BOTON CUANDO SE PRESIONA\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200); \n        }\n         a= gpio_get(button_pin); //TOMA EL VALOR DEL BOTON PIN\n\n        if (uart_is_readable(uart0)) { //SI HAY DATOS PARA LEER\n            char character = uart_getc(uart0); //LEE EL CARACTER\n            printf(character+\"\\n\"); //IMPRIME EL CARACTER RECIBIDO\n\n            if(character=='\\n' || character=='.'){ //CUANDO ENTRA UN PUNTO O UN ENTER\n                if (c == \"LEDON\"){\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n\n                } \n                else if (c == \"Invalid Command\"){\n                    printf(\"Invalid Command\\n\");\n\n                }\n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else{\n                c += character;\n            }\n        }\n    }\n}\n</code></pre>"}]}